From 31a09679200f8ce6e630fbcb3e079eb577d439fc Mon Sep 17 00:00:00 2001
From: Mark Enriquez <enriquezmark36@gmail.com>
Date: Tue, 9 Jun 2020 20:22:16 +0800
Subject: [PATCH 11/12] camera: kanas: Various updates, new features and
 changes

This only applies for the s5k4ecgx sensor.

Since I found some old copy of the s5k4ecgx datasheet
I could proceed doing some quick analyses on the register
and how it works.

For the Continuous AutoFocus, and the HDR Exposure Computation
algorithm is from this a driver by MediaTek:
https://github.com/dotOS-Devices/android_kernel_motorola_woods/blob/master/drivers/misc/mediatek/imgsensor/src/mt6735m/s5k4ecgx_mipi_yuv/s5k4ecgxmipi_yuv_Sensor.c

And yes, this is quite a massive update.

Here's a short highlight of what have changed:
    Additional images effects are added: Aqua and Sketch
    Continuous AutoFocus is now supported
    Night mode now supports flash
        Snap camera app in LineageOS does not.
        OpenCamera app does, though.
        If your camera app allows it, this is might be,
        the best method of capturing in a near pitch black area
	when the regular flash photography is not enough to
	create a visible image.
    New ISO800 and ISO600 option
        These are experimental ISO options, so be careful
    Infinity focus mode now works
        It actually now puts the focus as far as possible. This is
        not possible in the stock camera HAL blob
    Macro focus mode now works
    HDR mode now uses Manual exposure and Manual gains
        Expect HDR mode to be a bit faster and have a much stable
        range. Also expect HDR mode to be working well in both
        low light conditions and bright conditions.
    Preview Framerate register settings for 24 are added
    ISO values in the EXIF metadata is now computed from Analog and Digital Gains
        Expect a bit more accurate [citation needed] reading
    Exposure time should be more accurate in the EXIF metadata
    Added an option to disable or use the Auto anti-banding feature

Then the rest of the changelog:
    Maximum exposure time for Night mode is extended to 650 msec
    Maximum exposure time for low light capture is extended to 325 msec
    Red, Blue and Green tint image effects are now handled by the image sensor
        (meaning you could change WB settings while they're on)
    1024x768 video/preview resolution is now supported
    Added a workaround to boost sprd's devfreq governor 1280x*** recording
    1280x*** video/preview is now limited to 24fps max
        This should help reduce the DCAM line overflows
    Sharpness options is now implemented
        Before it was dummied to the Saturation options
    When identify fails, a power cycle is now attempted before retrying
    Fixed not being able to set 3+ brightness or 3+ contrast
    Fixed being able to set CAMERA_ISO_MAX ISO mode?
        This shouldn't be possible in the first place
    Removed white balance workaround in the image effects settings
        Red, Blue and Green tint image effects are now handled by the sensor
    It should be now possible to switch between scene modes safely
        Sometimes the effect of the previous scene mode still
        persists after switching. Also observable in the stock HAL lib.
    HDR scene mode will not apply previous scene mode anymore
    Low light capture now exhibits simillar effects to night mode
        Maybe except for the long exposure and a bit more noisy image.
    Flash photography should be a bit more reliable
        Expect less partial exposures.
    Fixed height and width messages in the logs, after each snapshot
        The height is actually the analog gain rather than the img height.
    A much more reliable workaround is in place for one time AF search
        More accurate log messages is displayed rather than "AF -Setup"
    AWB and AE is now unlocked after flash assisted one time AF search
    A point with zeroed height and width in touch AF is now invalid
        When this is encountered, AF windows are reset
    Some code and functions are clean up.
    When the scene mode does not override, user's ISO settings presists
        This is true except for the Auto/Default/Off scene mode
    Faster resolution switching due to fixed data races
        It seemed that setting values one by one can be interrupted
        by sending a whole reg table. This can cause the kernel driver
        to either write a wrong value in the right address or write
        the right in a wrong address.
    Fixed metering mode order, Center-weighted is now the default
        It is implied in the Auto scene mode.
    Log messages regarding light value's lsb and msb is now fixed
        They were switched.
    Shutter speed function can now properly get times longer than 163 msec
        The exposure time register is actually 4 bytes long not 2.
    Frame time function can now properly get times longer than 163 msec
        Same reason with the Shutter speed function
    ISO settings are imported from stock, with the anti flicker settings removed
    Any reg settings that change the REG_TC_DBG_AutoAlgEnBits has been tweaked
        A new function is written to properly handle that register
    Night scene mode's AF position tables is now prevented from being changed
        This can be changed before using the low light AF or setting
        a new focus mode.
    The waiting until AE is stable function checks 1 msec when fast AE is on
    Exposure Compensations now use the REG_TC_UserExposureVal88
        Exposure time is now changed rather than the Brightness
    Video recording on 1280x*** now have the exposure toned down a bit
        Should help with overexposure
    Video recording on 1280x*** will not set the Matrix metering mode

Change-Id: Ia6a3a9822ac4fa69d28a2f7d57bdeb20346cf5f4
Signed-off-by: Mark Enriquez <enriquezmark36@gmail.com>
---
 .../sc8830/inc/SprdCameraHardwareConfig.h     |   30 +-
 libcamera/scx15/sensor/sensor_s5k4ecgx_mipi.c | 1667 +++++++++++------
 .../scx15/sensor/sensor_s5k4ecgx_regs_mipi.h  | 1083 ++++++++---
 3 files changed, 2015 insertions(+), 765 deletions(-)

diff --git a/libcamera/scx15/sc8830/inc/SprdCameraHardwareConfig.h b/libcamera/scx15/sc8830/inc/SprdCameraHardwareConfig.h
index cfe2a93..43c34b7 100644
--- a/libcamera/scx15/sc8830/inc/SprdCameraHardwareConfig.h
+++ b/libcamera/scx15/sc8830/inc/SprdCameraHardwareConfig.h
@@ -37,6 +37,10 @@ enum {
 	CAMERA_EFFECT_YELLOW,
 	CAMERA_EFFECT_NEGATIVE,
 	CAMERA_EFFECT_SEPIA,
+#ifdef CONFIG_CAMERA_KANAS
+	CAMERA_EFFECT_AQUA,
+	CAMERA_EFFECT_SKETCH,
+#endif
 	CAMERA_EFFECT_MAX
 };
 
@@ -169,6 +173,7 @@ enum {
 #ifdef CONFIG_CAMERA_KANAS
 	CAMERA_ISO_50,
 	CAMERA_ISO_300,
+	CAMERA_ISO_600,
 #endif
 	CAMERA_ISO_MAX
 };
@@ -261,6 +266,8 @@ const struct str_map effect_map[] = {
 	{"green-tint",      CAMERA_EFFECT_GREEN},
 	{"blue-tint",       CAMERA_EFFECT_BLUE},
 	{"solarize",        CAMERA_EFFECT_YELLOW},
+	{"aqua",            CAMERA_EFFECT_AQUA},
+	{"sketch",          CAMERA_EFFECT_SKETCH},
 #endif
 	{NULL,              0}
 };
@@ -283,7 +290,7 @@ const struct str_map scene_mode_map[] = {
 	{"text",            CAMERA_SCENE_MODE_TEXT},
 	{"candlelight",     CAMERA_SCENE_MODE_CANDLELIGHT},
 	{"firework",        CAMERA_SCENE_MODE_FIREWORK},
-	{"back-light",       CAMERA_SCENE_MODE_BACKLIGHT},
+	{"back-light",      CAMERA_SCENE_MODE_BACKLIGHT},
 #endif
 	{NULL,              0}
 };
@@ -360,6 +367,7 @@ const struct str_map iso_map[] = {
 #ifdef CONFIG_CAMERA_KANAS
 	{"50",              CAMERA_ISO_50},
 	{"300",             CAMERA_ISO_300},
+	{"600",             CAMERA_ISO_600},
 #endif
 	{NULL,              0}
 };
@@ -600,7 +608,7 @@ struct config_element sprd_back_camera_hardware_config[] = {
 	{"preview-size", "640x480"},
 #else
 #ifdef CONFIG_CAMERA_KANAS
-	{"preview-size-values", "1280x960,1280x720,960x540,720x540,800x480,720x480,640x480,352x288,320x240,176x144"},
+	{"preview-size-values", "1280x960,1280x720,1024x768,960x540,720x540,800x480,720x480,640x480,352x288,320x240,176x144"},
 	{"preview-size", "800x480"},
 #else
 	{"preview-size-values", "1920x1088,1280x960,1280x720,960x540,720x540,720x480,640x480,352x288,320x240,176x144"},
@@ -637,7 +645,7 @@ struct config_element sprd_back_camera_hardware_config[] = {
 	{"jpeg-thumbnail-height", "480"},
 	{"jpeg-thumbnail-quality", "70"},
 #ifdef CONFIG_CAMERA_KANAS
-	{"effect-values", "none,mono,red-tint,green-tint,blue-tint,negative,sepia,solarize"},
+	{"effect-values", "none,mono,red-tint,green-tint,blue-tint,negative,sepia,solarize,aqua,sketch"},
 #else
     {"effect-values", "none,mono,negative,sepia,cold,antique"},
 #endif
@@ -675,7 +683,7 @@ struct config_element sprd_back_camera_hardware_config[] = {
 	{"sharpness", "3"},
 #endif
 #ifndef CONFIG_CAMERA_AUTOFOCUS_NOT_SUPPORT
-#if	defined(CONFIG_CAMERA_CAF)
+#if	defined(CONFIG_CAMERA_CAF) || defined(CONFIG_CAMERA_KANAS)
 	{"focus-mode-values", "auto,macro,continuous-picture,continuous-video,infinity"},
 	{"focus-mode", "auto"},
 #else
@@ -683,7 +691,11 @@ struct config_element sprd_back_camera_hardware_config[] = {
 	{"focus-mode", "auto"},
 #endif
 	{"focus-distances", "2.0,2.5,Infinity"},
+#if defined(CONFIG_CAMERA_KANAS)
+	{"max-num-focus-areas", "1"},
+#else
 	{"max-num-focus-areas", "3"},
+#endif
 #else
 	{"focus-mode-values", "infinity"},
 	{"focus-mode", "infinity"},
@@ -694,7 +706,11 @@ struct config_element sprd_back_camera_hardware_config[] = {
 	{"max-exposure-compensation", "3"},
 	{"exposure-compensation","0"},
 	{"exposure-compensation-step", "1"},
+#ifdef CONFIG_CAMERA_KANAS
+	{"antibanding-values","50hz,60hz,off,auto"},
+#else
 	{"antibanding-values","50hz,60hz"},
+#endif
 	{"antibanding","50hz"},
 	{"antibanding-supported","true"},
 #ifdef CONFIG_CAMERA_KANAS
@@ -725,7 +741,7 @@ struct config_element sprd_back_camera_hardware_config[] = {
 	{"iso-supported", "true"},
 	{"max-iso", "5"},
 #ifdef CONFIG_CAMERA_KANAS
-	{"iso-values", "auto,50,100,200,300,400"},
+	{"iso-values", "auto,50,100,200,300,400,600,800"},
 #else
 	{"iso-values", "auto,50,100,200,400,800,1600"},
 #endif
@@ -749,7 +765,11 @@ struct config_element sprd_back_camera_hardware_config[] = {
 #else
 	{"max-num-metering-areas", "0"},
 #endif
+#ifdef CONFIG_CAMERA_KANAS
+	{"auto-exposure","center-weighted"},
+#else
 	{"auto-exposure","frame-average"},
+#endif
 	{"auto-exposure-values", "frame-average,center-weighted,spot-metering"},
 	{"preview-env","0"},
 #if  defined(CONFIG_CAMERA_ZSL_CAPTURE)
diff --git a/libcamera/scx15/sensor/sensor_s5k4ecgx_mipi.c b/libcamera/scx15/sensor/sensor_s5k4ecgx_mipi.c
index 674a223..bb4f386 100644
--- a/libcamera/scx15/sensor/sensor_s5k4ecgx_mipi.c
+++ b/libcamera/scx15/sensor/sensor_s5k4ecgx_mipi.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2012 The Android Open Source Project
+ * Copyright (C) 2020 The Android Open Source Project
  *
  * Licensed under the Apache License, Version 2.0 (the "License");
  * you may not use this file except in compliance with the License.
@@ -14,12 +14,38 @@
  * limitations under the License.
  */
 
+#ifdef CONFIG_CAMERA_KANAS
+/*
+ * Workaround: Increase DDR frequency when using the 720p preview modes
+ * SPRD's devfreq ondemand governor is not fast or sensitive enough to
+ * raise the frequency when a load spike occurs.
+ * This spike will either cause an overflow, due to the slower processing
+ * on a recent burst of frames or an undefined behavior in the sensor.
+ */
+#define WA_BOOST_DDR_FREQ_720P
+
+/*
+ * Workaround: Limit Frame rate to 24 fps
+ * kanas3g can't seem to reach 30fps and only reaches about 26-27 fps.
+ * Since the DCAM line1 tx_error due to overflow is still present
+ * (WA_BOOST_DDR_FREQ_720P cannot fully prevent it from happening, sorry),
+ * Try to limit the maximum to some arbritrary framerate to save
+ * some processing power and help further prevent the said overflow.
+ */
+#define WA_LIMIT_HD_CAM_24FPS
+#endif
+
 #include <utils/Log.h>
+#include <errno.h>
 #include "sensor.h"
 #include "jpeg_exif_header.h"
 #include "sensor_drv_u.h"
 #include "cmr_oem.h"
 
+#ifdef WA_BOOST_DDR_FREQ_720P
+#include <stdio.h>
+#endif
+
 #include "sensor_s5k4ecgx_regs_mipi.h"
 
 #ifdef	 __cplusplus
@@ -50,17 +76,33 @@ LOCAL uint32_t is_cap = 0;
 LOCAL uint16_t s_current_shutter = 0;
 LOCAL uint16_t s_current_gain = 0;
 
-LOCAL uint16_t s_fps_cur_max = -1; // current max FPS (abs max is 30)
+
+// Global copy of states
+LOCAL uint8_t s_contrast_lvl = 3;
+LOCAL uint8_t s_sharpness_lvl = 3;
+LOCAL uint8_t s_saturation_lvl = 3;
+LOCAL uint8_t s_image_effect = 0;
+LOCAL uint8_t s_ISO_mode = 0;
+LOCAL uint8_t s_anti_flicker_mode = 0; //50Hz
+LOCAL uint8_t s_ev_comp_lvl = 3;
+
+LOCAL int16_t s_fps_cur_mode = -1; // current max FPS (abs max is 30)
+LOCAL int16_t s_target_max_fps = -1; // target max FPS
 LOCAL uint16_t s_current_env = 0; // 0 - Norm, 1 - Low Light, 2 - Night
-LOCAL uint16_t s_current_ev = 0;
 LOCAL uint16_t s_cur_scene = 0;
-LOCAL uint32_t s_flash_mode_en = 0;
 LOCAL uint32_t s_preview_mode = 0;
 LOCAL uint32_t s_white_balance = 0;
 
+// Local copy of Flash state (copied from the global context)
+LOCAL uint8_t s_flash_state = 0; // flash state in the global context
+LOCAL uint32_t s_torch_mode_en = 0;
+
+LOCAL uint8_t s_fast_ae_en = 0;
+LOCAL uint8_t s_stream_is_on = 0;
+
 // Local copy of state used by the HD camcorder settings
-LOCAL uint32_t s_brightness = 3; // Default value
-LOCAL uint32_t s_metering_mode = 0;
+LOCAL uint32_t s_brightness_lvl = 3; // Default value
+LOCAL uint32_t s_metering_mode = CAMERA_AE_CENTER_WEIGHTED;
 LOCAL  uint8_t s_hd_applied = 0;
 
 // Local AF states
@@ -68,6 +110,25 @@ LOCAL uint16_t s_focus_mode = 0;
 LOCAL  uint8_t s_using_low_light_af = 0;
 LOCAL  uint8_t s_af_wnd_has_changed = 0;
 
+// FPS modes
+enum {
+	FPS_MODE_AUTO = 0,
+	FPS_MODE_7,
+	FPS_MODE_10,
+	FPS_MODE_12,
+	FPS_MODE_15,
+	FPS_MODE_24,
+	FPS_MODE_25,
+	FPS_MODE_30,
+	FPS_MODE_MANUAL = 64,
+	FPS_MODE_OVERRIDE = 65,  // FPS setting is disabled
+	FPS_MODE_INVALID  = ((uint16_t) -1) >> 1,
+};
+
+#ifdef WA_BOOST_DDR_FREQ_720P
+LOCAL   int8_t s_ddr_boosted = 0;
+#endif
+
 LOCAL uint32_t _s5k4ec_InitExifInfo(void);
 LOCAL uint32_t _s5k4ec_GetResolutionTrimTab(uint32_t param);
 LOCAL uint32_t _s5k4ec_PowerOn(uint32_t power_on);
@@ -88,8 +149,8 @@ LOCAL uint32_t _s5k4ec_after_snapshot(uint32_t param);
 LOCAL uint32_t _s5k4ec_GetExifInfo(uint32_t param);
 LOCAL uint32_t _s5k4ec_ExtFunc(uint32_t ctl_param);
 LOCAL uint32_t _s5k4ec_StreamOn(uint32_t param);
+LOCAL uint32_t _s5k4ec_StreamOff(uint32_t param);
 LOCAL uint32_t _s5k4ec_set_iso(uint32_t level);
-LOCAL uint32_t _s5k4ec_recovery_init();
 
 // Additional functions
 LOCAL uint32_t s5k4ec_I2C_write(SENSOR_REG_T* sensor_reg_ptr);
@@ -104,6 +165,9 @@ LOCAL uint32_t __s5k4ecgx_set_focus_mode(uint32_t mode); // Force-set
 LOCAL uint32_t _s5k4ecgx_reset_focus_touch_position();
 LOCAL uint16_t s5k4ecgx_get_frame_time();
 LOCAL uint32_t s5k4ec_wait_until_ae_stable();
+LOCAL uint32_t s5k4ec_set_ae_awb_enable(uint32_t enable);
+LOCAL uint32_t s5k4ec_set_ae_enable(uint32_t enable);
+LOCAL uint32_t s5k4ec_set_awb_enable(uint32_t enable);
 
 LOCAL uint32_t s5k4ecgx_fast_ae(uint32_t on);
 LOCAL uint32_t s5k4ec_preflash_af(uint32_t on);
@@ -111,6 +175,12 @@ LOCAL uint32_t s5k4ec_main_flash(uint32_t on);
 LOCAL uint32_t s5k4ec_low_light_AF_check();
 LOCAL uint32_t s5k4ec_set_FPS(uint32_t fps);
 LOCAL uint32_t s5k4ec_set_FPS_mode(uint32_t fps_mode);
+LOCAL uint32_t s5k4ec_set_manual_FPS(uint32_t min, uint32_t max);
+LOCAL void s5k4ec_set_REG_TC_DBG_AutoAlgEnBits(int bit, int set);
+
+#ifdef WA_BOOST_DDR_FREQ_720P
+LOCAL int8_t s5k4ec_ddr_is_slow(int8_t boost);
+#endif
 
 LOCAL EXIF_SPEC_PIC_TAKING_COND_T s_s5k4ec_exif;
 
@@ -121,7 +191,7 @@ LOCAL SENSOR_REG_TAB_INFO_T s_s5k4ec_resolution_Tab_YUV[] = {
 	{ADDR_AND_LEN_OF_ARRAY(s5k4ec_320X240), 320, 240, 24, SENSOR_IMAGE_FORMAT_YUV422},
 	{ADDR_AND_LEN_OF_ARRAY(s5k4ec_640X480), 640, 480, 24, SENSOR_IMAGE_FORMAT_YUV422},
 	{ADDR_AND_LEN_OF_ARRAY(s5k4ec_720X540), 720, 540, 24, SENSOR_IMAGE_FORMAT_YUV422},
-	{ADDR_AND_LEN_OF_ARRAY(s5k4ec_1280X720), 1280, 720, 24, SENSOR_IMAGE_FORMAT_YUV422},
+	{ADDR_AND_LEN_OF_ARRAY(s5k4ec_1024X768), 1024, 768, 24, SENSOR_IMAGE_FORMAT_YUV422},
 
 	//YUV422 PREVIEW 2
 	{ADDR_AND_LEN_OF_ARRAY(s5k4ec_1280X960), 1280, 960, 24, SENSOR_IMAGE_FORMAT_YUV422},
@@ -134,7 +204,7 @@ LOCAL SENSOR_REG_TAB_INFO_T s_s5k4ec_resolution_Tab_YUV[] = {
 
 LOCAL uint32_t s5k4ec_set_awb_enable(uint32_t enable)
 {
-	uint16_t unlock = 1;
+	uint16_t unlock;
 
 	if (enable == 1) {
 		SENSOR_PRINT_HIGH("Unlock AWB");
@@ -149,7 +219,7 @@ LOCAL uint32_t s5k4ec_set_awb_enable(uint32_t enable)
 
 	Sensor_WriteReg(0xFCFC, 0xD000);
 	Sensor_WriteReg(0x0028, 0x7000);
-	Sensor_WriteReg(0x002A, 0x2c66);
+	Sensor_WriteReg(0x002A, 0x2C66);
 	Sensor_WriteReg(0x0F12, unlock);
 
 	return 0;
@@ -157,7 +227,7 @@ LOCAL uint32_t s5k4ec_set_awb_enable(uint32_t enable)
 
 LOCAL uint32_t s5k4ec_set_ae_enable(uint32_t enable)
 {
-	uint16_t unlock = 1;
+	uint16_t unlock;
 
 	if (enable == 1) {
 		SENSOR_PRINT_HIGH("Unlock AE");
@@ -175,8 +245,13 @@ LOCAL uint32_t s5k4ec_set_ae_enable(uint32_t enable)
 	Sensor_WriteReg(0x002A, 0x2C5E);
 	Sensor_WriteReg(0x0F12, unlock);
 
-	s5k4ec_set_awb_enable(enable);
+	return 0;
+}
 
+LOCAL uint32_t s5k4ec_set_ae_awb_enable(uint32_t enable)
+{
+	s5k4ec_set_ae_enable(enable);
+	s5k4ec_set_awb_enable(enable);
 	return 0;
 }
 
@@ -189,7 +264,7 @@ LOCAL SENSOR_TRIM_T s_s5k4ec_Resolution_Trim_Tab[]=
 	{0, 0, 320, 240, 680, 648, 40, {0, 0, 320, 240}},
 	{0, 0, 640, 480, 680, 648, 40, {0, 0, 640, 480}},
 	{0, 0, 720, 540, 680, 648, 40, {0, 0, 720, 540}},
-	{0, 0, 1280, 720, 664, 648, 0, {0, 0, 1280, 720}},
+	{0, 0, 1024, 768, 664, 648, 0, {0, 0, 1024, 768}},
 
 	//YUV422 PREVIEW 2
 	{0, 0, 1280, 960, 664, 648, 0, {0, 0, 1280, 960}},
@@ -197,7 +272,6 @@ LOCAL SENSOR_TRIM_T s_s5k4ec_Resolution_Trim_Tab[]=
 	{0, 0, 2048, 1536, 660, 648, 0, {0, 0, 2048, 1536}},
 	{0, 0, 2560, 1920, 660, 648, 0, {0, 0, 2560, 1920}},
 
-	{0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0}},
 	{0, 0, 0, 0, 0, 0, 0, {0, 0, 0, 0}}
 };
 
@@ -214,7 +288,7 @@ LOCAL SENSOR_IOCTL_FUNC_TAB_T s_s5k4ec_ioctl_func_tab =
 	_s5k4ec_GetResolutionTrimTab,//PNULL,/*7*/
 
 	// External
-	s5k4ec_set_ae_enable,/*8*/
+	s5k4ec_set_ae_awb_enable,/*8*/
 	PNULL,/*9*/
 	PNULL,/*10*/
 	_s5k4ec_set_brightness,/*11*/
@@ -249,7 +323,7 @@ LOCAL SENSOR_IOCTL_FUNC_TAB_T s_s5k4ec_ioctl_func_tab =
 	s5k4ec_set_Metering,/*40*///set_meter_mode
 	PNULL, /*41*///get_status
 	_s5k4ec_StreamOn,/*42*///stream_on
-	PNULL,//_s5k4ec_StreamOff/*43*/// stream_off
+	_s5k4ec_StreamOff,//_s5k4ec_StreamOff/*43*/// stream_off
 	NULL,
 };
 
@@ -328,11 +402,23 @@ SENSOR_INFO_T g_s5k4ec_mipi_yuv_info =
 	1,                     // skip frame num while change setting
 };
 
+LOCAL int32_t _gcd(int32_t a, int32_t b)
+{
+	for (int32_t r; b > 0; ) {
+		r = a % b;
+		a = b;
+		b = r;
+	}
+
+	return a;
+}
+
 LOCAL uint32_t _s5k4ec_GetExifInfo(__attribute__((unused)) uint32_t param)
 {
 	EXIF_SPEC_PIC_TAKING_COND_T* exif_ptr=&s_s5k4ec_exif;
 	uint32_t shutter_speed;
 	uint16_t iso_value;
+	int32_t gcd_shutter;
 
 	iso_value = s5k4ec_get_ISO_rate();
 
@@ -348,8 +434,10 @@ LOCAL uint32_t _s5k4ec_GetExifInfo(__attribute__((unused)) uint32_t param)
 		exif_ptr->valid.ExposureTime = 0;
 	} else {
 		exif_ptr->valid.ExposureTime = 1;
-		exif_ptr->ExposureTime.numerator = 1;
-		exif_ptr->ExposureTime.denominator = shutter_speed;
+
+		gcd_shutter = _gcd(shutter_speed, 400000);
+		exif_ptr->ExposureTime.numerator = shutter_speed / gcd_shutter;
+		exif_ptr->ExposureTime.denominator = 400000 / gcd_shutter;
 	}
 
 	return (unsigned long)exif_ptr;
@@ -437,18 +525,8 @@ LOCAL uint32_t _s5k4ec_GetResolutionTrimTab(__attribute__((unused)) uint32_t par
 	return (unsigned long)s_s5k4ec_Resolution_Trim_Tab;
 }
 
-LOCAL uint32_t _s5k4ec_PowerOn(uint32_t power_on)
+LOCAL uint32_t __s5k4ec_PowerOn(uint32_t power_on)
 {
-#ifndef CONFIG_CAMERA_IOCTL_IOCTL_HAS_POWER_ONOFF
-	/*
-	 * Some devices have a convenience IOCTL SENSOR_IO_POWER_ONOFF that
-	 * will handle the process of turning this on and off.
-	 * The CONFIG_CAMERA_IOCTL_IOCTL_HAS_POWER_ONOFF when set will
-	 * attempt to call that only after the poweron function has
-	 * been called.
-	 * If that IOCTL is present, it is advisable to use that instead
-	 * of this.
-	 */
 	SENSOR_AVDD_VAL_E dvdd_val = g_s5k4ec_mipi_yuv_info.dvdd_val;
 	SENSOR_AVDD_VAL_E avdd_val = g_s5k4ec_mipi_yuv_info.avdd_val;
 	SENSOR_AVDD_VAL_E iovdd_val = g_s5k4ec_mipi_yuv_info.iovdd_val;
@@ -494,7 +572,35 @@ LOCAL uint32_t _s5k4ec_PowerOn(uint32_t power_on)
 		Sensor_SetMonitorVoltage(SENSOR_AVDD_CLOSED);
 		SENSOR_Sleep(10);
 	}
+	return 0;
+}
+
+LOCAL uint32_t _s5k4ec_PowerOn(uint32_t power_on)
+{
+#ifndef CONFIG_CAMERA_IOCTL_IOCTL_HAS_POWER_ONOFF
+	/*
+	 * Some devices offer a convenience IOCTL, SENSOR_IO_POWER_ONOFF, that
+	 * will handle the process of turning this on and off.
+	 * The CONFIG_CAMERA_IOCTL_IOCTL_HAS_POWER_ONOFF when set will
+	 * attempt to call that only after the poweron function has
+	 * been called.
+	 * If that IOCTL is present, it is advisable to use that instead
+	 * of this.
+	 */
+	__s5k4ec_PowerOn(power_on);
+#endif
+
+#ifdef WA_BOOST_DDR_FREQ_720P
+	if (s_ddr_boosted) {
+		s5k4ec_ddr_is_slow(0);
+	}
 #endif
+
+	if (s_torch_mode_en) {
+		s_torch_mode_en = 0;
+		Sensor_SetFlash(FLASH_CLOSE);
+	}
+
 	SENSOR_PRINT_HIGH("(1:on, 0:off): %u", power_on);
 
 	return SENSOR_SUCCESS;
@@ -540,7 +646,11 @@ LOCAL uint32_t _s5k4ec_Identify(__attribute__((unused)) uint32_t param)
 
 			if (i != max_attmp) {
 				SENSOR_PRINT_HIGH("Retrying after 100 msec");
+
+				// Power cycle
+				__s5k4ec_PowerOn(0);
 				SENSOR_Sleep(100);
+				__s5k4ec_PowerOn(1);
 			} else {
 				SENSOR_PRINT_HIGH("Bailing out");
 			}
@@ -553,23 +663,41 @@ LOCAL uint32_t _s5k4ec_Identify(__attribute__((unused)) uint32_t param)
 		//_s5k4ec_set_vendorid();
 
 		/*
-		 * Initialize our local states, again.
-		 * Just to be sure. Setting it again will not hurt
-		 * But not setting it at all will.
+		 * Reinitialize all the local state variables
+		 * Expecially if we are recovering from a sudden crash
 		 */
-		s_fps_cur_max = -1; // current max FPS (abs max is 30)
+		s_contrast_lvl = 3;
+		s_sharpness_lvl = 3;
+		s_saturation_lvl = 3;
+		s_image_effect = 0;
+		s_ISO_mode = 0;
+		s_anti_flicker_mode = 0;
+		s_ev_comp_lvl = 3;
+
+		s_fps_cur_mode = -1;
+		s_target_max_fps = -1;
 		s_current_env = 0; // 0 - Norm, 1 - Low Light, 2 - Night
-		s_current_ev = 0;
 		s_cur_scene = 0;
-		s_flash_mode_en = 0;
 		s_preview_mode = 0;
 		s_white_balance = 0;
-		s_brightness = 3; // Default value
+
+		// Local copy of Flash state (copied from the global context)
+		s_flash_state = 0; // flash state in the global context
+		s_torch_mode_en = 0;
+
+		// Local copy of state used by the HD camcorder settings
+		s_brightness_lvl = 3; // Default value
+		s_metering_mode = CAMERA_AE_CENTER_WEIGHTED;
 		s_hd_applied = 0;
-		s_metering_mode = 0;
+
+		// Local AF states
 		s_focus_mode = 0;
 		s_using_low_light_af = 0;
 		s_af_wnd_has_changed = 0;
+
+		// Misc
+		s_fast_ae_en = 0;
+		s_stream_is_on = 0;
 	}
 
 	return ret_value;
@@ -577,278 +705,366 @@ LOCAL uint32_t _s5k4ec_Identify(__attribute__((unused)) uint32_t param)
 
 LOCAL uint32_t _s5k4ec_set_brightness(uint32_t level)
 {
-	if (level > 7) {
+	if (level > 6) {
 		SENSOR_PRINT_ERR("Undefined Brightness level %u", level);
-		return 0;
+		return SENSOR_OP_PARAM_ERR;
 	}
+
 	SENSOR_PRINT_HIGH("Apply Brightness level %u", level);
 
-	s5k4ec_I2C_write(s5k4ec_brightness_tab[level]);
-	s_brightness = level;
+	s5k4ec_I2C_write(s5k4ec_ae_brightness_tab[level]);
+	s_brightness_lvl = level;
 	Sensor_SetSensorExifInfo(SENSOR_EXIF_CTRL_BRIGHTNESSVALUE, (uint32_t) level);
 
-	return 0;
+	return SENSOR_SUCCESS;
 }
 
 LOCAL uint32_t _s5k4ec_set_contrast(uint32_t level)
 {
-	if (level > 7) {
+	if (level > 6) {
 		SENSOR_PRINT_ERR("Undefined Contrast level %u", level);
-		return 0;
+		return SENSOR_OP_PARAM_ERR;
 	}
 
 	SENSOR_PRINT_HIGH("Apply Contrast level %u", level);
 
 	s5k4ec_I2C_write(s5k4ec_contrast_tab[level]);
+	s_contrast_lvl = level;
 	Sensor_SetSensorExifInfo(SENSOR_EXIF_CTRL_CONTRAST, (uint32_t) level);
 
-	return 0;
+	return SENSOR_SUCCESS;
 }
 
 LOCAL uint32_t _s5k4ec_set_iso(uint32_t level)
 {
-	if (CAMERA_ISO_MAX < level) {
+	if (CAMERA_ISO_MAX <= level) {
 		SENSOR_PRINT_ERR("Undefined ISO mode %u", level);
-		return 0;
+		return SENSOR_OP_PARAM_ERR;
 	}
 
 	SENSOR_PRINT_HIGH("Apply ISO mode %u", level);
 
 	switch(level) {
-		case CAMERA_ISO_50:
-			s5k4ec_I2C_write(s5k4ec_ISO_50);
-			break;
-		case CAMERA_ISO_100:
-			s5k4ec_I2C_write(s5k4ec_ISO_100);
-			break;
-		case CAMERA_ISO_200:
-			s5k4ec_I2C_write(s5k4ec_ISO_200);
-			break;
-		case CAMERA_ISO_300: /* This value is linearly interpolated */
-			s5k4ec_I2C_write(s5k4ec_ISO_300);
-			break;
-		/*
-		 * Maximum iso gain is about 5232 which is about
-		 * 400 ISO as it seems with the msm implementation
-		 * and the stock rom. AUTO ISO might never
-		 * reach this level, but would still appear
-		 * on the Exif data as 400 ISO though.
-		 */
-		case CAMERA_ISO_400:
-		case CAMERA_ISO_800:
-		case CAMERA_ISO_1600:
-			s5k4ec_I2C_write(s5k4ec_ISO_400);
-			break;
-
-		/*
-		 * If ever the check passed but with an unknown value
-		 * default to auto.
-		 */
-		default:
-		case CAMERA_ISO_AUTO:
-			s5k4ec_I2C_write(s5k4ec_ISO_auto);
-			break;
+	case CAMERA_ISO_50:
+		s5k4ec_I2C_write(s5k4ec_ISO_50);
+		break;
+	case CAMERA_ISO_100:
+		s5k4ec_I2C_write(s5k4ec_ISO_100);
+		break;
+	case CAMERA_ISO_200:
+		s5k4ec_I2C_write(s5k4ec_ISO_200);
+		break;
+	case CAMERA_ISO_300: /* This value is linearly interpolated */
+		s5k4ec_I2C_write(s5k4ec_ISO_300);
+		break;
+	case CAMERA_ISO_400:
+		s5k4ec_I2C_write(s5k4ec_ISO_400);
+		break;
+	/*
+	 * These values are experimental
+	 * To be frank, the factory settings only allow auto ISO
+	 * go up to around ISO400, with or without Digital Gain.
+	 * It's possible to use Higher ISO settings but doing so
+	 * will cause much increase in noise with some unexplored
+	 * side effects.
+	 */
+	case CAMERA_ISO_600:
+		s5k4ec_I2C_write(s5k4ec_ISO_600);
+		break;
+	case CAMERA_ISO_800:
+	case CAMERA_ISO_1600:
+		s5k4ec_I2C_write(s5k4ec_ISO_800);
+		break;
 
+	/*
+	 * If ever the check passed but with an unknown value
+	 * default to auto.
+	 */
+	default:
+	case CAMERA_ISO_AUTO:
+		s5k4ec_I2C_write(s5k4ec_ISO_auto);
+		break;
 	}
 
-        return 0;
+	s_ISO_mode = level;
+
+	return SENSOR_SUCCESS;
 }
 
 LOCAL uint32_t _s5k4ec_set_saturation(uint32_t level)
 {
 	if (level > 6) {
 		SENSOR_PRINT_ERR("Undefined Saturation level %u", level);
-		return 0;
+		return SENSOR_OP_PARAM_ERR;
 	}
 
 	SENSOR_PRINT_HIGH("Apply Saturation level %u",level);
 	s5k4ec_I2C_write(s5k4ec_saturation_tab[level]);
+	s_saturation_lvl = level;
 
-	return 0;
+	return SENSOR_SUCCESS;
 }
 
 LOCAL uint32_t _s5k4ec_set_image_effect(uint32_t effect_type)
 {
-	static uint8_t should_revert_WB = 0;
-	if (effect_type > 8) {
-		SENSOR_PRINT_ERR("Undefined Image Effect type %u", effect_type);
-		return 0;
+	if (effect_type > 9) {
+		SENSOR_PRINT_ERR("Undefined Image Effect #%u", effect_type);
+		return SENSOR_OP_PARAM_ERR;
 	}
 
 	SENSOR_PRINT_HIGH("Apply Image Effect type %u", effect_type);
 	s5k4ec_I2C_write(s5k4ec_image_effect_tab[effect_type]);
+	s_image_effect = (int8_t) effect_type;
 
-	/*
-	 * Work around to image effects affecting the whitebalance.
-	 * Switching to None should also revert the alteration to WB.
-	 */
-	if (effect_type >= 2 && effect_type <= 4) {
-		should_revert_WB = 1;
-	} else if (should_revert_WB) {
-		SENSOR_PRINT_HIGH("Reverting White Balance from effects.");
-		_s5k4ec_set_awb(s_white_balance);
-		should_revert_WB = 0;
-	}
-
-	return 0;
+	return SENSOR_SUCCESS;
 }
 
 LOCAL uint32_t _s5k4ec_set_ev(uint32_t level)
 {
+	const uint16_t hd_mode_offset = 0x8;
 	if (level > 6) {
 		SENSOR_PRINT_ERR("Undefined Exposure Compensation level %u", level);
-		return 0;
+		return SENSOR_OP_PARAM_ERR;
 	}
 
 	SENSOR_PRINT_HIGH("Apply Exposure Compensation level %u", level);
-	s_current_ev = level;
-	s5k4ec_I2C_write(s5k4ec_ev_tab[level]);
 
-	return 0;
+	if (s_hd_applied) {
+		SENSOR_PRINT_HIGH("HD settings detected, apply offset -%u", hd_mode_offset);
+		Sensor_WriteReg(0x0028, 0x7000);
+		Sensor_WriteReg(0x002A, 0x023A); // REG_TC_UserExposureVal88
+		SENSOR_PRINT_HIGH("Apply %u", s5k4ec_ev_tab[level][2].reg_value - hd_mode_offset);
+		Sensor_WriteReg(0x0F12, s5k4ec_ev_tab[level][2].reg_value - hd_mode_offset);
+	} else {
+		s5k4ec_I2C_write(s5k4ec_ev_tab[level]);
+	}
+
+	s_ev_comp_lvl = (int8_t) level;
+
+	return SENSOR_SUCCESS;
 }
 
 LOCAL uint32_t _s5k4ec_set_anti_flicker(uint32_t mode)
 {
-	if (mode > 6) {
+	const char *str = "";
+	if (mode >= CAMERA_MAX_ANTIBANDING) {
 		SENSOR_PRINT_ERR("Undefined Anti-banding mode %u", mode);
-		return 0;
+		return SENSOR_OP_PARAM_ERR;
+	}
+
+	if (mode == CAMERA_ANTIBANDING_50HZ) {
+		str = "Applying 50Hz";
+	} else if (mode == CAMERA_ANTIBANDING_60HZ) {
+		str = "Applying 60Hz";
+	} else if (mode == CAMERA_ANTIBANDING_OFF) {
+		str = "Disabling ";
+	} else if (mode == CAMERA_ANTIBANDING_AUTO) {
+		str = "Applying Auto";
 	}
 
-	SENSOR_PRINT_HIGH("Applied %s Anti-banding", mode ? "50Hz" : "60Hz");
+	SENSOR_PRINT_HIGH("%s Anti-banding", str);
+
+	// Deactivate auto anti flicker algorithm when
+	if (mode == CAMERA_ANTIBANDING_AUTO)
+		s5k4ec_set_REG_TC_DBG_AutoAlgEnBits(AA_FLICKER, 1);
+	else
+		s5k4ec_set_REG_TC_DBG_AutoAlgEnBits(AA_FLICKER, 0);
+
 	s5k4ec_I2C_write(s5k4ec_anti_banding_flicker_tab[mode]);
+	s_anti_flicker_mode = (int8_t) mode;
 
-	return 0;
+	return SENSOR_SUCCESS;
 }
 
 LOCAL uint32_t _s5k4ec_set_video_mode(uint32_t mode)
 {
 	struct camera_context *cxt = camera_get_cxt();
+	s_target_max_fps = cxt->cmr_set.frame_rate;
 
 	SENSOR_PRINT_HIGH("mode = 0x%X", mode);
 
 	SENSOR_PRINT_HIGH("cxt->sn_cxt.preview_mode=%u s_preview_mode=%u", cxt->sn_cxt.preview_mode, s_preview_mode);
-	if (s_preview_mode != cxt->sn_cxt.preview_mode) {
-		if (1280 <= s_s5k4ec_resolution_Tab_YUV[cxt->sn_cxt.preview_mode].width) {
-			if (!s_hd_applied) {
-				SENSOR_PRINT_HIGH("Applying HD camcorder settings");
-				s5k4ec_I2C_write(s5k4ec_enable_camcorder);
-			}
+	if (1280 <= s_s5k4ec_resolution_Tab_YUV[cxt->sn_cxt.preview_mode].width){
+		if (!s_hd_applied) {
+			SENSOR_PRINT_HIGH("Applying HD camcorder settings");
+			s5k4ec_I2C_write(s5k4ec_enable_camcorder);
 			s_hd_applied = 1;
-		} else if (s_hd_applied) {
-			SENSOR_PRINT_HIGH("Reverting HD camcorder settings");
-			s5k4ec_I2C_write(s5k4ec_disable_camcorder);
-
-			// revert AE
-			_s5k4ec_set_brightness(s_brightness);
 
-			// Revert Metering setting
-			if (s_metering_mode != 0) // matrix
-				s5k4ec_set_Metering(s_metering_mode);
-			s_hd_applied = 0;
+			_s5k4ec_set_ev(s_ev_comp_lvl);
 		}
+	} else if (s_hd_applied) {
+		SENSOR_PRINT_HIGH("Reverting HD camcorder settings");
+		s5k4ec_I2C_write(s5k4ec_disable_camcorder);
+
+		// revert AE settings
+		//_s5k4ec_set_brightness(s_brightness_lvl);
+		_s5k4ec_set_ev(s_ev_comp_lvl);
+
+		// Revert Sharpness setting, default level is 3
+		s5k4ec_set_sharpness(s_sharpness_lvl);
 
-		s5k4ec_I2C_write(s5k4ec_preview_return);
+		// Revert Metering setting
+		// s5k4ec_set_Metering(s_metering_mode);
+
+		s_hd_applied = 0;
 	}
 
 	s_preview_mode = cxt->sn_cxt.preview_mode;
-	s5k4ec_set_FPS(cxt->cmr_set.frame_rate);
 
-	return 0;
+	return SENSOR_SUCCESS;
 }
 
 LOCAL uint32_t _s5k4ec_set_awb(uint32_t mode)
 {
 	if (mode > 6) {
 		SENSOR_PRINT_ERR("Undefined Auto White Balance mode %u",mode);
-		return 0;
+		return SENSOR_OP_PARAM_ERR;
 	}
 
 	SENSOR_PRINT_HIGH("Apply Auto White Balance mode %u", mode);
+	if (mode == 0) // AWB mode
+		s5k4ec_set_REG_TC_DBG_AutoAlgEnBits(AA_WB_ACTIVE, 1);
+	else
+		s5k4ec_set_REG_TC_DBG_AutoAlgEnBits(AA_WB_ACTIVE, 0);
+
 	s5k4ec_I2C_write(s5k4ec_awb_tab[mode]);
 	s_white_balance = mode;
 
 	Sensor_SetSensorExifInfo(SENSOR_EXIF_CTRL_LIGHTSOURCE, (uint32_t) mode);
 	Sensor_SetSensorExifInfo(SENSOR_EXIF_CTRL_WHITEBALANCE, (uint32_t) mode);
 
-	return 0;
+	return SENSOR_SUCCESS;
 }
 
 LOCAL uint32_t _s5k4ec_set_scene_mode(uint32_t mode)
 {
 	SENSOR_PRINT_HIGH("Apply Scene mode %u", mode);
 
-	switch (mode) {
-		case CAMERA_SCENE_MODE_AUTO:
-			s5k4ec_I2C_write(s5k4ec_scene_off);
-			break;
-		case CAMERA_SCENE_MODE_NIGHT:
-			s5k4ec_I2C_write(s5k4ec_scene_night);
-			break;
+	if (s_cur_scene == mode) {
+		SENSOR_PRINT_HIGH("Already applied");
+		return SENSOR_SUCCESS;
+	}
+
+	if (mode != CAMERA_SCENE_MODE_AUTO) {
+		SENSOR_PRINT_HIGH("Trying to revert changes from the previous scene mode");
+		switch (s_cur_scene) {
 		case CAMERA_SCENE_MODE_PORTRAIT:
-			s5k4ec_I2C_write(s5k4ec_scene_portrait);
+		case CAMERA_SCENE_MODE_TEXT:
+			s5k4ec_I2C_write(s5k4ec_scene_revert_sharpness0);
 			break;
 		case CAMERA_SCENE_MODE_LANDSCAPE:
-			s5k4ec_I2C_write(s5k4ec_scene_landscape);
+			s5k4ec_I2C_write(s5k4ec_scene_revert_sharpness0);
+			s5k4ec_set_Metering(s_metering_mode);
+			break;
+		case CAMERA_SCENE_MODE_NIGHT:
+			s5k4ec_I2C_write(s5k4ec_scene_revert_night);
+			s5k4ec_I2C_write(s5k4ec_scene_revert_gain);
+			__s5k4ecgx_set_focus_mode(s_focus_mode);
 			break;
 		case CAMERA_SCENE_MODE_SPORTS:
-			s5k4ec_I2C_write(s5k4ec_scene_sports);
+		case CAMERA_SCENE_MODE_FIREWORK:
+			s5k4ec_I2C_write(s5k4ec_scene_revert_sports);
+			s5k4ec_I2C_write(s5k4ec_scene_revert_gain);
+			// _s5k4ec_set_iso(s_ISO_mode); // Moved to StreamOn()
 			break;
 		case CAMERA_SCENE_MODE_PARTY:
-			s5k4ec_I2C_write(s5k4ec_scene_party);
+			s5k4ec_I2C_write(s5k4ec_scene_revert_sports);
+			_s5k4ec_set_saturation(s_saturation_lvl);
 			break;
 		case CAMERA_SCENE_MODE_BEACH:
-			s5k4ec_I2C_write(s5k4ec_scene_beach);
-			break;
-		case CAMERA_SCENE_MODE_SUNSET:
-			s5k4ec_I2C_write(s5k4ec_scene_sunset);
-			break;
-		case CAMERA_SCENE_MODE_DUSK_DAWN:
-			s5k4ec_I2C_write(s5k4ec_scene_dawn);
+			s5k4ec_I2C_write(s5k4ec_scene_revert_sports);
+			_s5k4ec_set_saturation(s_saturation_lvl);
+			_s5k4ec_set_brightness(s_brightness_lvl);
 			break;
 		case CAMERA_SCENE_MODE_FALL_COLOR:
-			s5k4ec_I2C_write(s5k4ec_scene_fall);
+			_s5k4ec_set_saturation(s_saturation_lvl);
 			break;
-		case CAMERA_SCENE_MODE_TEXT:
-			s5k4ec_I2C_write(s5k4ec_scene_text);
+		case CAMERA_SCENE_MODE_BACKLIGHT:
+			s5k4ec_set_Metering(s_metering_mode);
 			break;
+
+		// These three scenes just adjusts the White balance and disables AWB
+		case CAMERA_SCENE_MODE_SUNSET:
+		case CAMERA_SCENE_MODE_DUSK_DAWN:
 		case CAMERA_SCENE_MODE_CANDLELIGHT:
-			s5k4ec_I2C_write(s5k4ec_scene_candlelight);
-			break;
-		case CAMERA_SCENE_MODE_FIREWORK:
-			s5k4ec_I2C_write(s5k4ec_scene_firework);
-			break;
-		case CAMERA_SCENE_MODE_BACKLIGHT:
-			s5k4ec_I2C_write(s5k4ec_scene_backlight);
+			_s5k4ec_set_awb(s_white_balance);
+			/* Fall-through */
+		default:
 			break;
+		}
+		SENSOR_PRINT_HIGH("Revert Done.");
+	}
 
-		case CAMERA_SCENE_MODE_HDR:
-			/*
-			 * Try to use the previous mode as the template
-			 * Mode of HDR. Just check that it's not
-			 * CAMERA_SCENE_MODE_HDR or we'll have
-			 * infinite recursion.
-			 */
-			SENSOR_PRINT_ERR("HDR: setting previous mode %u", s_cur_scene);
-			_s5k4ec_set_scene_mode(s_cur_scene);
+	switch (mode) {
+	case CAMERA_SCENE_MODE_AUTO:
+		s5k4ec_I2C_write(s5k4ec_scene_off);
+		break;
+	case CAMERA_SCENE_MODE_NIGHT:
+		s5k4ec_I2C_write(s5k4ec_scene_night);
+		break;
+	case CAMERA_SCENE_MODE_PORTRAIT:
+		s5k4ec_I2C_write(s5k4ec_scene_portrait);
+		break;
+	case CAMERA_SCENE_MODE_LANDSCAPE:
+		s5k4ec_I2C_write(s5k4ec_scene_landscape);
+		break;
+	case CAMERA_SCENE_MODE_SPORTS:
+		s5k4ec_I2C_write(s5k4ec_scene_sports);
+		break;
+	case CAMERA_SCENE_MODE_PARTY:
+		s5k4ec_I2C_write(s5k4ec_scene_party);
+		break;
+	case CAMERA_SCENE_MODE_BEACH:
+		s5k4ec_I2C_write(s5k4ec_scene_beach);
+		break;
+	case CAMERA_SCENE_MODE_SUNSET:
+		s5k4ec_set_REG_TC_DBG_AutoAlgEnBits(AA_WB_ACTIVE, 0); // Disables AWB
+		s5k4ec_I2C_write(s5k4ec_scene_sunset);
+		break;
+	case CAMERA_SCENE_MODE_DUSK_DAWN:
+		s5k4ec_set_REG_TC_DBG_AutoAlgEnBits(AA_WB_ACTIVE, 0); // Disables AWB
+		s5k4ec_I2C_write(s5k4ec_scene_dawn);
+		break;
+	case CAMERA_SCENE_MODE_FALL_COLOR:
+		s5k4ec_I2C_write(s5k4ec_scene_fall);
+		break;
+	case CAMERA_SCENE_MODE_TEXT:
+		s5k4ec_I2C_write(s5k4ec_scene_text);
+		break;
+	case CAMERA_SCENE_MODE_CANDLELIGHT:
+		s5k4ec_set_REG_TC_DBG_AutoAlgEnBits(AA_WB_ACTIVE, 0); // Disables AWB
+		s5k4ec_I2C_write(s5k4ec_scene_candlelight);
+		break;
+	case CAMERA_SCENE_MODE_FIREWORK:
+		s5k4ec_I2C_write(s5k4ec_scene_firework);
+		break;
+	case CAMERA_SCENE_MODE_BACKLIGHT:
+		s5k4ec_I2C_write(s5k4ec_scene_backlight);
+		break;
 
-			return SENSOR_SUCCESS; // ignore the error
-		case CAMERA_SCENE_MODE_ACTION:
-		case CAMERA_SCENE_MODE_NORMAL:
-		default:
-			SENSOR_PRINT_ERR("Undefined Scene mode %u", mode);
-		return SENSOR_SUCCESS; // ignore the error
+	case CAMERA_SCENE_MODE_HDR:
+		/* Do nothing */
+		break;
+	case CAMERA_SCENE_MODE_ACTION:
+	case CAMERA_SCENE_MODE_NORMAL:
+	default:
+		SENSOR_PRINT_ERR("Undefined Scene mode %u", mode);
+	return SENSOR_SUCCESS; // ignore the error
 	}
 
-	Sensor_SetSensorExifInfo(SENSOR_EXIF_CTRL_SCENECAPTURETYPE,(uint32_t) mode);
+	if (mode == CAMERA_SCENE_MODE_HDR)
+		Sensor_SetSensorExifInfo(SENSOR_EXIF_CTRL_SCENECAPTURETYPE, mode);
+	else
+		Sensor_SetSensorExifInfo(SENSOR_EXIF_CTRL_SCENECAPTURETYPE, s_cur_scene);
+
 	s_cur_scene = mode;
 	return SENSOR_SUCCESS;
 }
 
 LOCAL uint32_t _s5k4ec_BeforeSnapshot(uint32_t param)
 {
-	struct camera_context *cxt = camera_get_cxt();
 	uint32_t capture_mode = param & 0xffff;
-	s_flash_mode_en = cxt->cmr_set.flash;
+	struct camera_context *cxt = camera_get_cxt();
 
 	SENSOR_PRINT_HIGH("Begin. capture_mode=%d", capture_mode);
 
@@ -856,27 +1072,71 @@ LOCAL uint32_t _s5k4ec_BeforeSnapshot(uint32_t param)
 		is_cap = 1;
 
 	// Use the global context to find out whether we are using
-	// camera flash or not (assuming the autoflash has been
-	// reduced to a YES or NO flash question)
-	if (FLASH_CLOSE != s_flash_mode_en)
-		s5k4ec_main_flash(1);
-
-	if (LIGHT_STATUS_IS_LOW(s5k4ec_lightcheck())) {
+	// camera flash or not
+	// NOTE: Night and Firework scenes, and HDR don't use flash
+	if ((FLASH_CLOSE != s_flash_state) &&
+	    (s_cur_scene != CAMERA_SCENE_MODE_NIGHT) &&
+	    (s_cur_scene != CAMERA_SCENE_MODE_FIREWORK)){
+		SENSOR_PRINT_HIGH("Flash will be used, not applying any low light tweaks");
+	} else if (LIGHT_STATUS_IS_LOW(s5k4ec_lightcheck())) {
+		/*
+		 * This code block should only run when flash will never be used
+		 * in this shot. These settings will allow the shutter
+		 * speed to be slower than 1/8th second which will never
+		 * guarantee that the flash would cover a complete cycle
+		 */
 		SENSOR_PRINT_HIGH("Low light environment detected");
 		if (s_cur_scene == CAMERA_SCENE_MODE_NIGHT ||
-			s_cur_scene == CAMERA_SCENE_MODE_FIREWORK) {
+		    s_cur_scene == CAMERA_SCENE_MODE_FIREWORK) {
 			SENSOR_PRINT_HIGH("Night mode activate");
 			s5k4ec_I2C_write(s5k4ec_night_mode_On);
 			s_current_env = 2;
+
+			/*
+			 * We could actually support flash with Night Scene mode
+			 * but not the full "High Light" flash since it
+			 * won't last the entire shutter cycle. We could, however, use
+			 * the dimmer "Torch" flash (basically the flashlight mode)
+			 * to act as the supplemental light source. The longer
+			 * exposure should compensate for the drastically dimmer light.
+			 */
+			if (s_flash_state) {
+				SENSOR_PRINT_HIGH("It seems that flash will be used, using torch instead");
+				s_torch_mode_en = 1;
+				Sensor_SetFlash(FLASH_OPEN/*FLASH_TORCH*/);
+
+				s5k4ec_set_ae_awb_enable(1);
+				s5k4ecgx_fast_ae(1);
+
+				s5k4ec_wait_until_ae_stable();
+
+				s5k4ecgx_fast_ae(0);
+				s5k4ec_set_ae_awb_enable(0);
+			}
+		} else if (s_cur_scene == CAMERA_SCENE_MODE_SPORTS) {
+			/*
+			 * The Sports scene mode cannot have low light capture tweaks with
+			 * or without flash since that's the only mode that's designed
+			 * to be a sanic in capturing fast moving objects.
+			 * The shutter speed should go fast in that use case.
+			 */
+			SENSOR_PRINT_HIGH("But still not applying any low light tweaks.");
 		} else {
+			/*
+			 * We won't support flash like what  we did with the night mode
+			 * Use night mode if they want that.
+			 */
 			SENSOR_PRINT_HIGH("Low cap mode activate");
+			s5k4ec_I2C_write(s5k4ec_capture_med_FPS); // medium exposure (~325 msecs)
 			s5k4ec_I2C_write(s5k4ec_low_cap_On);
 			s_current_env = 1;
 		}
+	} else { // normal capture
+		s5k4ec_I2C_write(s5k4ec_capture_short_FPS); // normal exposure (~125 msecs)
 	}
 
 	Sensor_SetMode(capture_mode);
-	SENSOR_Sleep(10);
+	SENSOR_Sleep(10); // wait since Sensor_SetMode() is async
 
 	SENSOR_PRINT_HIGH("s_current_shutter,s_current_gain = %x,%x", s_current_shutter,s_current_gain);
 	return SENSOR_SUCCESS;
@@ -972,95 +1232,48 @@ LOCAL uint32_t _s5k4ec_chang_image_format(uint32_t param)
 LOCAL uint32_t _s5k4ec_after_snapshot(uint32_t param)
 {
 	SENSOR_PRINT_HIGH("=========sonia SENSOR: _s5k4ec_after_snapshot %u",param);
-	uint16_t width, height=0;
+	uint16_t width = 0, height = 0;
 
-	if (FLASH_CLOSE != s_flash_mode_en)
+	// Revert reg settings regarding flash and disable non Highlight flash
+	if (FLASH_CLOSE != s_flash_state)
 		s5k4ec_main_flash(0);
 
-	// Reset the low (light) capture settings as soon as possible.
-	if (2 == s_current_env) {
+	if (s_torch_mode_en) {
+		s_torch_mode_en = 0;
+		Sensor_SetFlash(FLASH_CLOSE);
+	}
+
+	// Reset the low light capture settings as soon as possible.
+	if (2 == s_current_env)
 		s5k4ec_I2C_write(s5k4ec_night_mode_Off);
-	} else if (1 == s_current_env) {
+	else if (1 == s_current_env)
 		s5k4ec_I2C_write(s5k4ec_low_cap_Off);
-	}
 	s_current_env = 0;
 
-	//_s5k4ec_recovery_init();
+	// Restore previous sensor mode (which is the preview mode)
 	Sensor_SetMode((uint32_t)param);
-	//SENSOR_Sleep(10);
+	SENSOR_Sleep(10); // NOTE: Sensor_SetMode() is async, wait for it.
+	s5k4ec_I2C_write(s5k4ec_preview_return);
 	is_cap = 0;
 
-
+	// Retrieve information about the size of the captured image
 	Sensor_WriteReg(0x002C, 0x7000);
 	Sensor_WriteReg(0x002E, 0x1D02);
-	width = Sensor_ReadReg(0x0f12);
-	Sensor_WriteReg(0x002E, 0x2BC4);
+	width = Sensor_ReadReg(0x0F12);
 	height = Sensor_ReadReg(0x0F12);
-	SENSOR_PRINT_HIGH("width=%x, height=%x",width,height);
+	SENSOR_PRINT_HIGH("width=0x%X(%u), height=0x%X(%u)", width, width, height, height);
 
 	return SENSOR_SUCCESS;
 }
 
-LOCAL uint32_t _s5k4ec_MatchZone(SENSOR_EXT_FUN_T_PTR param_ptr)
-{
-	SENSOR_RECT_T zone_rect;
-	uint32_t rtn=SENSOR_SUCCESS;
-	memset((void*)&zone_rect, 0, sizeof(SENSOR_RECT_T));
-	switch (param_ptr->cmd)
-	{
-	case SENSOR_EXT_FOCUS_START:
-			switch (param_ptr->param)
-			{
-			case SENSOR_EXT_FOCUS_ZONE:
-			case SENSOR_EXT_FOCUS_MULTI_ZONE:
-					zone_rect.w = FOCUS_ZONE_W;
-					zone_rect.h = FOCUS_ZONE_H;
-					break;
-			default:
-					break;
-			}
-			break;
-	case SENSOR_EXT_EXPOSURE_START:
-			switch (param_ptr->param)
-			{
-			case SENSOR_EXT_EXPOSURE_ZONE:
-					zone_rect.w = EXPOSURE_ZONE_W;
-					zone_rect.h = EXPOSURE_ZONE_H;
-					break;
-			default:
-					break;
-			}
-			break;
-	 default:
-		  break;
-	}
-
-	if ((0x00 != s_s5k4ec_resolution_Tab_YUV[SENSOR_MODE_PREVIEW_ONE].width)&& (0x00 !=s_s5k4ec_resolution_Tab_YUV[SENSOR_MODE_PREVIEW_ONE].height)
-	    && (0x00 != zone_rect.w)&& (0x00 != zone_rect.h))
-	{
-		param_ptr->zone.x =(zone_rect.w * param_ptr->zone.x) /
-		    s_s5k4ec_resolution_Tab_YUV[SENSOR_MODE_PREVIEW_ONE].width;
-		param_ptr->zone.y =(zone_rect.h * param_ptr->zone.y) /
-		    s_s5k4ec_resolution_Tab_YUV[SENSOR_MODE_PREVIEW_ONE].height;
-	}
-	else
-	{
-		SENSOR_PRINT_ERR("SENSOR: _s5k4ec_MatchZone, w:%d, h:%d error \n",zone_rect.w, zone_rect.h);
-		rtn = SENSOR_FAIL;
-	}
-
-	SENSOR_PRINT_HIGH("SENSOR: _s5k4ec_MatchZone, x:%d, y:%d \n",param_ptr->zone.x, param_ptr->zone.y);
-	return rtn;
-}
-
-LOCAL uint32_t _s5k4ec_AutoFocusTrig(__attribute__((unused)) SENSOR_EXT_FUN_PARAM_T_PTR param_ptr)
+LOCAL uint32_t _s5k4ec_AutoFocusTrig(SENSOR_EXT_FUN_PARAM_T_PTR param_ptr)
 {
 	struct camera_context *cxt = camera_get_cxt();
 	uint32_t rtn = SENSOR_FAIL;
 	uint16_t reg_value;
-	uint16_t frame_time = s5k4ecgx_get_frame_time();
+	uint16_t frame_time;
 	int8_t flash_mode = cxt->cmr_set.flash;
-	int fresh = 1, retries = 7; // for workaround
+	int fresh = 1, wait = 5, restart_wait = 0; // for workaround
 	int i;
 
 	SENSOR_PRINT_HIGH("Start");
@@ -1075,9 +1288,11 @@ LOCAL uint32_t _s5k4ec_AutoFocusTrig(__attribute__((unused)) SENSOR_EXT_FUN_PARA
 
 		s5k4ec_wait_until_ae_stable();
 		// Lock AWB + AE
-		_s5k4ec_set_awb(0);
+		s5k4ec_set_ae_awb_enable(0);
 	}
 
+	frame_time = s5k4ecgx_get_frame_time();
+
 	s5k4ec_I2C_write(s5k4ec_single_AF_start);
 
 	/*
@@ -1085,10 +1300,10 @@ LOCAL uint32_t _s5k4ec_AutoFocusTrig(__attribute__((unused)) SENSOR_EXT_FUN_PARA
 	 * first phase, too early or we would get an error
 	 * value.
 	 */
-	SENSOR_Sleep(frame_time*2);
+	SENSOR_Sleep(frame_time * 2);
 
 
-	for (i = 30; i--; ) {
+	for (i = 35; i--;) {
 		SENSOR_Sleep(frame_time);
 		Sensor_WriteReg(0x002C, 0x7000);
 		Sensor_WriteReg(0x002E, 0x2EEE);
@@ -1103,31 +1318,59 @@ LOCAL uint32_t _s5k4ec_AutoFocusTrig(__attribute__((unused)) SENSOR_EXT_FUN_PARA
 			continue;
 		}
 
-		// Erroneous state, when reg_value is
-		// either of the following: 0,3,4,6,8
-		// In the case of both timeout and error
-		// Give the error message a higher precedence
-		if (reg_value != 0x1 || reg_value != 2) {
+		/*
+		 * According to the old datasheet, the read register values
+		 * have a meaning, not all of it are errors.
+		 * 0 - Idle AF                  6 - AF Scene Detecting (AE related)
+		 * 1 - AF searching             7 - AF Scene Detecting
+		 * 2 - AF search success        8 - AF Scene Detecting (AF Window related)
+		 * 3 - Low confidence position
+		 * 4 - AF was cancelled         *any other value - probably an error
+		 */
+		if ((reg_value == 6) || (reg_value == 7) || (reg_value == 8) || (reg_value == 0)) {
 			/*
 			 * Issue: Unknown delay between AF start and progress checks.
 			 * Specially after setting the AF window, there would be
-			 * some unknown delay before the AF can actually start.
-			 * Unfortunately, it also seemed that it's independent of
-			 * the frame rate. One characteristic of this problem
-			 * is that it only happens at the start of each AF focusing.
+			 * some unknown delay. Unfortunately, it also seemed
+			 * that it's independent of the frame rate.
+			 * AF search will start automatically afterwards.
 			 *
-			 * If we get an error at the start, try to skip it up to
-			 * 7 times. When a single Progress is received, we go on
-			 * as usual.
+			 * Issue: When changing from CAF to AF, it might take more time
+			 * to initiate a single AF search causing the reg_value at
+			 * 0x70002EEE to be 0. AF search will never start in most cases.
 			 */
-			if ((fresh == 1) && retries) {
-				SENSOR_PRINT_ERR("[1st]AF -Setup");
-				retries--;
-				continue;
+			if (fresh == 1) {
+				if (reg_value) {
+					SENSOR_PRINT_ERR("[1st]AF -Detecting (%u)", reg_value);
+					continue;
+				} else if (wait) {
+					if (!(restart_wait--)) {
+						SENSOR_PRINT_ERR("[1st]AF -Restart AF");
+						s5k4ec_I2C_write(s5k4ec_single_AF_start);
+						restart_wait = 2;
+					} else {
+						SENSOR_PRINT_ERR("[1st]AF -Waiting");
+					}
+					wait--;
+					continue;
+				} else {
+					SENSOR_PRINT_ERR("[1st]AF -Wait timed out! ");
+				}
+			} else {
+				SENSOR_PRINT_ERR("[1st]AF -Error! (%u)", reg_value);
 			}
 
-			SENSOR_PRINT_ERR("[1st]AF -Error!");
-		} else if (i <= 0) {
+		} else if (reg_value == 4)  {
+			SENSOR_PRINT_ERR("[1st]AF -Cancelled!");
+			goto cleanup;
+		} else if (reg_value == 3)  {
+			// Low Confidence AF search result automatically cancels
+			// no need to send the s5k4ec_AF_off_1 reg setting
+			SENSOR_PRINT_ERR("[1st]AF -Low confidence result");
+			goto cleanup;
+		} else if (i > 0) { //etc
+			SENSOR_PRINT_ERR("[1st]AF -Error! (%u)", reg_value);
+		} else {
 			SENSOR_PRINT_ERR("[1st]AF -Timeout!");
 		}
 
@@ -1162,18 +1405,13 @@ cleanup:
 	if (flash_mode != FLASH_CLOSE) {
 		s5k4ecgx_fast_ae(0);
 		s5k4ec_preflash_af(0);
+		s5k4ec_set_ae_awb_enable(1);
 	}
 	SENSOR_PRINT_HIGH("Done.");
 
 	return rtn;
 }
 
-LOCAL uint32_t _s5k4ec_AutoFocusMultiZone(__attribute__((unused)) SENSOR_EXT_FUN_PARAM_T_PTR param_ptr)
-{
-	SENSOR_PRINT_ERR("Not yet implemented");
-	return SENSOR_SUCCESS;
-}
-
 LOCAL uint32_t _s5k4ecgx_set_focus_touch_position(SENSOR_EXT_FUN_PARAM_T_PTR param_ptr)
 {
 	uint16_t reg_value;
@@ -1188,7 +1426,9 @@ LOCAL uint32_t _s5k4ecgx_set_focus_touch_position(SENSOR_EXT_FUN_PARAM_T_PTR par
 	height = s_s5k4ec_resolution_Tab_YUV[s_preview_mode].height;
 	touch_x = param_ptr->zone[0].x;
 	touch_y = param_ptr->zone[0].y;
-	SENSOR_PRINT_HIGH("Start x=%d, y=%d, w=%d, h=%d, width=%d height=%d",
+
+	SENSOR_PRINT_HIGH(
+		"Start x=%d, y=%d, w=%d, h=%d, width=%d height=%d",
 		param_ptr->zone[0].x,param_ptr->zone[0].y, param_ptr->zone[0].w, param_ptr->zone[0].h,
 		width, height
 	);
@@ -1196,10 +1436,18 @@ LOCAL uint32_t _s5k4ecgx_set_focus_touch_position(SENSOR_EXT_FUN_PARAM_T_PTR par
 	if (touch_x < 0 || touch_y < 0) {
 		SENSOR_PRINT_HIGH("Invalid coordinates, reseting AF window setting");
 		_s5k4ecgx_reset_focus_touch_position();
+		return 0;
 	}
 
-	Sensor_WriteReg(0xFCFC, 0xD000);
-	Sensor_WriteReg(0x002C, 0x7000);
+	if (!touch_x && !touch_y && !param_ptr->zone[0].w && !param_ptr->zone[0].h) {
+		SENSOR_PRINT_HIGH("Rectangle at (0,0) w=0 and h=0 considered invalid.");
+		_s5k4ecgx_reset_focus_touch_position();
+		return 0;
+	}
+
+
+	Sensor_WriteReg(0xFCFC, 0xD000);
+	Sensor_WriteReg(0x002C, 0x7000);
 	Sensor_WriteReg(0x002E, 0x0298);
 	reg_value = Sensor_ReadReg(0x0F12);
 	SENSOR_PRINT_HIGH("outer_width : 0x%X(%d)", reg_value, reg_value);
@@ -1230,7 +1478,7 @@ LOCAL uint32_t _s5k4ecgx_set_focus_touch_position(SENSOR_EXT_FUN_PARAM_T_PTR par
 	/*
 	 * After this code block lies a copy-pasted code to determine the
 	 * coordinates of top-left corners of the two AF search windows.
-	 * Re-read the last paragraph if you didn't get something was up.
+	 * Re-read the previous sentence if you didn't get something was up.
 	 *
 	 * The coordinates are already given but why calculate it?
 	 *
@@ -1369,27 +1617,20 @@ LOCAL uint32_t _s5k4ec_StartAutoFocus(uint32_t param)
 	SENSOR_EXT_FUN_PARAM_T_PTR ext_ptr = (SENSOR_EXT_FUN_PARAM_T_PTR) param;
 	SENSOR_PRINT_HIGH("Start. param = %d", ext_ptr->param);
 
-	s5k4ec_low_light_AF_check();
-
-	// This function usualy is activated when doing AF mode is macro
-	// But some camera apps doesn't even expose changing AF modes...
-	_s5k4ecgx_set_focus_touch_position(ext_ptr);
-
 	switch (ext_ptr->param) {
-	case SENSOR_EXT_FOCUS_MULTI_ZONE:
-		rtn = _s5k4ec_AutoFocusMultiZone(ext_ptr);
-		break;
+	case SENSOR_EXT_FOCUS_TRIG:
 	case SENSOR_EXT_FOCUS_MACRO:
+		s5k4ec_low_light_AF_check();
+		// This function usualy is activated when doing AF mode is macro
+		// But some camera apps doesn't even expose changing AF modes...
+		_s5k4ecgx_set_focus_touch_position(ext_ptr);
+
 		rtn |= _s5k4ec_AutoFocusTrig(ext_ptr);
 		break;
-	case SENSOR_EXT_FOCUS_TRIG:
-		// Function not in vendor blob, used to revert any changes by
-		// _s5k4ecgx_set_focus_touch_position().
-		// Uncomment when you used _s5k4ecgx_set_focus_touch_position()
-		// only for AF Macro.
-		// rtn = _s5k4ecgx_reset_focus_touch_position();
-		rtn |= _s5k4ec_AutoFocusTrig(ext_ptr);
+	case SENSOR_EXT_FOCUS_CAF:
+	case SENSOR_EXT_FOCUS_MULTI_ZONE:
 	case SENSOR_EXT_FOCUS_ZONE:
+	case SENSOR_EXT_FOCUS_CHECK_AF_GAIN:
 	default:
 		break;
 	}
@@ -1397,122 +1638,196 @@ LOCAL uint32_t _s5k4ec_StartAutoFocus(uint32_t param)
 	return rtn;
 }
 
-LOCAL uint32_t _s5k4ec_ExposureAuto(void)
+/*
+ * The function below sets the exposure and gain by using
+ * the sensor's AE algorithm.
+ * Works great most of the time unless if its in low light
+ * environments.
+ */
+#if 0
+LOCAL uint32_t _s5k4ec_SetEV(uint32_t param)
 {
-	SENSOR_PRINT_ERR("Not implemented");
+	uint32_t rtn = SENSOR_SUCCESS;
+	SENSOR_EXT_FUN_PARAM_T_PTR ext_ptr = (SENSOR_EXT_FUN_PARAM_T_PTR) param;
+	uint32_t ev = ext_ptr->param;
+	int16_t level = 3;
 
-	return SENSOR_SUCCESS;
-}
+	static int16_t save_level;
+	static int8_t restore_needed = 0;
 
-LOCAL uint32_t _s5k4ec_ExposureZone(__attribute__((unused)) SENSOR_EXT_FUN_T_PTR param_ptr)
-{
-	SENSOR_PRINT_ERR("Not implemented");
+	SENSOR_PRINT_HIGH("param: 0x%x", ext_ptr->param);
 
-	return SENSOR_SUCCESS;
-}
+	switch(ev) {
+	case SENSOR_HDR_EV_LEVE_0:
+		save_level = s_ev_comp_lvl;
+		level = 4;
+		break;
+	case SENSOR_HDR_EV_LEVE_1:
+		/*
+		 * Sprd's libcamera calls this function with param
+		 * SENSOR_HDR_EV_LEVE_1 twice: first as a HDR step
+		 * and second to restore the EV Comp setting.
+		 */
+		if (!restore_needed) { // as an HDR step
+			level = 5;
+		} else { // restore the EV Compensation setting
+			level = save_level;
+		}
+		restore_needed = !restore_needed;
+		break;
+	case SENSOR_HDR_EV_LEVE_2:
+		level = 6;
+		break;
+	default:
+		SENSOR_PRINT_ERR("Undefined parameter level");
+		return 0;
+	}
 
-LOCAL uint32_t _s5k4ec_StartExposure(uint32_t param)
-{
-	uint32_t rtn=SENSOR_SUCCESS;
+	s5k4ec_I2C_write(s5k4ec_preview_return);
 
-	SENSOR_EXT_FUN_T_PTR ext_ptr=(SENSOR_EXT_FUN_T_PTR)param;
+	s5k4ec_set_ae_enable(1);
+	s5k4ecgx_fast_ae(1);
 
-	SENSOR_PRINT("param=%d", ext_ptr->param);
-	switch (ext_ptr->param) {
-		case SENSOR_EXT_EXPOSURE_AUTO:
-			rtn = _s5k4ec_ExposureAuto();
-			break;
-		case SENSOR_EXT_EXPOSURE_ZONE:
-			rtn = _s5k4ec_ExposureZone(ext_ptr);
-		/* Fall-through */
-		default:
-			break;
+	if (level < 0) {
+		Sensor_WriteReg(0x0028, 0x7000);
+		Sensor_WriteReg(0x002A, 0x023A); // REG_TC_UserExposureVal88
+		Sensor_WriteReg(0x0F12, 0x0056); // 0x100 -- default
+	} else if (level > 6) {
+		Sensor_WriteReg(0x0028, 0x7000);
+		Sensor_WriteReg(0x002A, 0x023A); // REG_TC_UserExposureVal88
+		Sensor_WriteReg(0x0F12, 0x0300);
+	} else {
+		_s5k4ec_set_ev(level);
 	}
 
+	s5k4ec_wait_until_ae_stable();
+	s5k4ecgx_fast_ae(0);
+	s5k4ec_set_ae_enable(0);
 	return rtn;
 }
-
+#endif
+/*
+ * The function below disables the AE algorithm and manually
+ * computes the exposure and gain.
+ * The computation is based on the last EV and ISO values
+ * the AE algorithm has set.
+ * Works OK all of the time, even in low light environments.
+ */
 LOCAL uint32_t _s5k4ec_SetEV(uint32_t param)
 {
+#define MAX_A_D_GAIN (16 << 8) //max combined analog+digital gain, 16x (~800ISO)
+#define MAX_EV_TIME ( 650 * 100) // max exposure time, 650ms
+
 	uint32_t rtn = SENSOR_SUCCESS;
 	SENSOR_EXT_FUN_PARAM_T_PTR ext_ptr = (SENSOR_EXT_FUN_PARAM_T_PTR) param;
+	uint16_t f_gain = 0;
+	uint16_t f_ev = 0;
 
-	SENSOR_PRINT("SENSOR: _s5k4ec_SetEV param: 0x%x", ext_ptr->param);
-	uint32_t shutter = 0;
-	uint32_t gain = 0;
+	static int8_t restore_needed = 0;
+	static int32_t ev;
+	static int32_t gain;
+	static int32_t manual_ev;
+	static int32_t manual_gain;
+	static int16_t auto_algorithm_en; // REG_TC_DBG_AutoAlgEnBits
 
-	uint32_t ev = ext_ptr->param;
-	switch(ev) {
+	SENSOR_PRINT_HIGH("param: 0x%x", ext_ptr->param);
+
+	switch(ext_ptr->param) {
 	case SENSOR_HDR_EV_LEVE_0:
-		s5k4ec_I2C_write(s5k4ec_ev_tab[0]);
+		SENSOR_PRINT_HIGH("Backup AE, EV and Gain settings");
+		// Calculate Exposure time
+		Sensor_WriteReg(0xFCFC, 0xD000);
+		Sensor_WriteReg(0x002C, 0x7000);
+		Sensor_WriteReg(0x002E, 0x2C28);
+		ev = Sensor_ReadReg(0x0F12);
+		ev += Sensor_ReadReg(0x0F12) << 16;
+		ev = ev >> 2;
+		SENSOR_PRINT_HIGH("ev=0x%X(%f)\n", ev, (float)ev / 100);
+
+		// Calculate sensor Gains
+		// NOTE: Analog and Digital gains are in 8.8 fixed point numbers
+		Sensor_WriteReg(0x002C, 0x7000);
+		Sensor_WriteReg(0x002E, 0x2BC4);
+		gain = Sensor_ReadReg(0x0F12); //A gain
+		gain = gain * Sensor_ReadReg(0x0F12); //D gain
+		// NOTE: By this line, gain is a 16.16 fixed-point number
+		// But the sensor only reads 8.8 values
+		// We need to reduce its precision.
+		// formula: let x=>16.16 number, y=>temp variable, z=>result
+		//          y = x / (2 ^ 16) // convert to real number
+		//          z = y * (2 ^ 8)  // convert back to 8.8 fp number
+		//          z = x / (2 ^ 8)  // Simplified form
+		gain =  gain >> 8;
+		// CAUTION: If this gain value goes under 1, you may want
+		//          to check why that happens.
+		SENSOR_PRINT_HIGH("gain=0x%X(%f)\n", gain, (float)gain / 256);
+
+		// Backup auto algorithm switches
+		Sensor_WriteReg(0x002C, 0x7000);
+		Sensor_WriteReg(0x002E, 0x04E6);
+		auto_algorithm_en = Sensor_ReadReg(0x0F12);
+		SENSOR_PRINT_HIGH("AutoAlgEn=0x%X\n", auto_algorithm_en);
+
+		// Backup manual EV and Gain
+		Sensor_WriteReg(0x002C, 0x7000);
+		Sensor_WriteReg(0x002E, 0x04AC);
+		manual_ev = Sensor_ReadReg(0x0F12);
+		manual_ev |= Sensor_ReadReg(0x0F12) << 16;
+		Sensor_WriteReg(0x002E, 0x04B2);
+		manual_gain = Sensor_ReadReg(0x0F12);
+		SENSOR_PRINT_HIGH("m_gain=0x%X m_ev=ox%X\n", manual_gain, manual_ev);
+
+		SENSOR_PRINT_HIGH("Backup Done, this will be restored later.");
+
+		// Disable LEI adjustments and AE algorithms
+		Sensor_WriteReg(0x0028, 0x7000);
+		Sensor_WriteReg(0x002A, 0x04E6);
+		Sensor_WriteReg(0x0F12, auto_algorithm_en & 0xFFF9);
+
+		f_gain = gain / 2;
+		f_ev = ev / 2;
 		break;
 	case SENSOR_HDR_EV_LEVE_1:
-		s5k4ec_I2C_write(s5k4ec_ev_tab[3]);
+		if (!restore_needed) { // as an HDR step
+			f_gain = gain;
+			f_ev = ev;
+		} else {
+			SENSOR_PRINT_HIGH("HDR has finished, will restore values now.");
+			// Restore defaults
+			f_gain = manual_gain;
+			f_ev = manual_ev;
+
+			// Restore auto algorithm switches
+			Sensor_WriteReg(0x0028, 0x7000);
+			Sensor_WriteReg(0x002A, 0x04E6);
+			Sensor_WriteReg(0x0F12, auto_algorithm_en);
+		}
+		restore_needed = !restore_needed;
 		break;
 	case SENSOR_HDR_EV_LEVE_2:
-		s5k4ec_I2C_write(s5k4ec_ev_tab[6]);
+		f_gain = gain * 2;
+		f_ev = ev * 2;
 		break;
 	default:
-		break;
+		SENSOR_PRINT_ERR("Undefined parameter level");
+		return 0;
 	}
-	return rtn;
-}
 
-LOCAL uint8_t af_firmware[] = {
-	#if 0 //\B2\BB\D3\C3AF
-	0x80,
-	0x00,
-	#endif
-};
+	f_gain = (f_gain > MAX_A_D_GAIN) ? MAX_A_D_GAIN : f_gain;
+	f_ev = (f_ev > MAX_EV_TIME) ? MAX_EV_TIME : f_ev;
 
-LOCAL int _s5k4ec_init_firmware(uint32_t param)
-{
-	int ret = 0;
-	uint32_t i = 0;
-	uint32_t init_num = NUMBER_OF_ARRAY(af_firmware);
-	SENSOR_EXT_FUN_PARAM_T_PTR ext_ptr = (SENSOR_EXT_FUN_PARAM_T_PTR)param;
-	uint8_t  *reg_ptr = af_firmware;
-	uint16_t reg_val_1,reg_val_2;
-
-	SENSOR_PRINT_HIGH("SENSOR: _s5k4ec_init_firmware: cmd=%d!.\n", ext_ptr->cmd);
-	switch (ext_ptr->param)	{
-	 case SENSOR_EXT_FOCUS_TRIG:	//auto focus
-		    reg_ptr = af_firmware;
-		    break;
-	 default:
-		    break;
-	}
+	SENSOR_PRINT_HIGH("f_gain=0x%X(%f)\n", f_gain, (float)f_gain / 256);
+	SENSOR_PRINT_HIGH("f_ev=0x%X(%f msec) \n", f_ev, (float)f_ev / 100);
 
-	Sensor_WriteReg(0x3000, 0x20);
-	for (i = 0; i < 4; i++) {
-		ret = Sensor_WriteData(reg_ptr, init_num);
-		if (ret != 0) {
-			SENSOR_PRINT_ERR("SENSOR: write sensor reg fai, ret : %d\n", ret);
-			continue;
-		}
-		break;
-	}
-// 	Sensor_WriteReg(0x3022, 0x00);
-	Sensor_WriteReg(0x3023, 0x00);
-	Sensor_WriteReg(0x3024, 0x00);
-	Sensor_WriteReg(0x3025, 0x00);
-	Sensor_WriteReg(0x3026, 0x00);
-	Sensor_WriteReg(0x3027, 0x00);
-	Sensor_WriteReg(0x3028, 0x00);
-	Sensor_WriteReg(0x3029, 0x7F);
-	Sensor_WriteReg(0x3000, 0x00);
-
-	reg_val_1 = Sensor_ReadReg(0x3000);
-	reg_val_2 = Sensor_ReadReg(0x3004);
-	//      sc8810_i2c_set_clk(1,100000); //wjp
-	SENSOR_PRINT_HIGH("SENSOR: _s5k4ec_init_firmware: E!.\n");
-#if 0
-	//SENSOR_PRINT_HIGH("SENSOR: 0x3029=0x%x,0x3000=0x%x,0x3004=0x%x.\n",Sensor_ReadReg(0x3029),reg_val_1,reg_val_2);
-	//SENSOR_PRINT_HIGH("SENSOR: 0x8000=0x%x,0x8002=0x%x,0x8f57=0x%x.\n",Sensor_ReadReg(0x8000),Sensor_ReadReg(0x8002),Sensor_ReadReg(0x8f57));
-#endif
-	return ret;
-}
+	Sensor_WriteReg(0x002A, 0x04AC);
+	Sensor_WriteReg(0x0F12, (int16_t) (f_ev & 0xFFFF));   // REG_SF_USER_Exposure
+	Sensor_WriteReg(0x0F12, (int16_t) (f_ev >> 16));      // REG_SF_USER_ExposureHigh
+	Sensor_WriteReg(0x0F12, 0x0001);         // REG_SF_USER_ExposureChanged
+	Sensor_WriteReg(0x0F12, f_gain);         // REG_SF_USER_TotalGain
+	Sensor_WriteReg(0x0F12, 0x0001);         // REG_SF_USER_TotalGainChanged
 
+	return rtn;
+}
 
 LOCAL uint32_t _s5k4ec_ExtFunc(uint32_t ctl_param)
 {
@@ -1524,16 +1839,15 @@ LOCAL uint32_t _s5k4ec_ExtFunc(uint32_t ctl_param)
 	switch (ext_ptr->cmd)
 	{
 	 case SENSOR_EXT_FUNC_INIT:
-		rtn = _s5k4ec_init_firmware(ctl_param);
+		// rtn = _s5k4ec_init_firmware(ctl_param);
 		break;
 	 case SENSOR_EXT_FOCUS_START:
 		rtn = _s5k4ec_StartAutoFocus(ctl_param);
 		break;
-	case SENSOR_EXT_EXPOSURE_START:
-		rtn = _s5k4ec_StartExposure(ctl_param);
-		break;
 	case SENSOR_EXT_EV:
 		rtn = _s5k4ec_SetEV(ctl_param);
+		break;
+	case SENSOR_EXT_EXPOSURE_START:
 	default:
 		    break;
 	}
@@ -1541,47 +1855,118 @@ LOCAL uint32_t _s5k4ec_ExtFunc(uint32_t ctl_param)
 	return rtn;
 }
 
-LOCAL uint32_t _s5k4ec_recovery_init()
-{
-	SENSOR_PRINT("SENSOR: s5k4ec_steamon recovery\n");
-
-	Sensor_WriteReg(0x0028, 0x7000);
-	Sensor_WriteReg(0x002A, 0x0242);
-	Sensor_WriteReg(0x0F12, 0x0000);	//#REG_TC_GP_EnablePreview
-
-	Sensor_WriteReg(0x0028, 0xD000);
-	Sensor_WriteReg(0x002A, 0xB0A0);
-	Sensor_WriteReg(0x0F12, 0x0000);	//Clear cont. clock befor config change
-
-	Sensor_WriteReg(0x0028, 0x7000);
-	Sensor_WriteReg(0x002A, 0x0244);
-	Sensor_WriteReg(0x0F12, 0x0001);	//#REG_TC_GP_EnablePreviewChanged
-	return 0;
-}
-
 LOCAL uint32_t _s5k4ec_StreamOn(__attribute__((unused)) uint32_t param)
 {
 	SENSOR_PRINT_HIGH("SENSOR:Start s5k4ec_steamon 1613");
 
 	if (1 != is_cap) {
 		SENSOR_PRINT_HIGH("zxdbg preview stream on");
-		Sensor_WriteReg(0x0028, 0x7000);
-		Sensor_WriteReg(0x002A, 0x023E);
-		Sensor_WriteReg(0x0F12, 0x0001);  //#REG_TC_GP_EnablePreview
-		Sensor_WriteReg(0x0F12, 0x0001);  //#REG_TC_GP_EnablePreviewChanged
 
-		Sensor_WriteReg (0x0028, 0xD000);
-		Sensor_WriteReg(0x002A, 0x1000);
-		Sensor_WriteReg(0x0F12, 0x0001);
-		SENSOR_Sleep(10);
+		/*
+		 * NOTE: There is no reason to manually activate the
+		 * preview stream, even when changing resolutions
+		 * since the REG_TC_GP_PrevOpenAfterChange register
+		 * will open it when it's set to 1.
+		 */
+		// s5k4ec_I2C_write(s5k4ec_preview_Stream_On);
+		// SENSOR_Sleep(10);
+
+
+		if ((s_cur_scene != CAMERA_SCENE_MODE_BEACH) ||
+		    (s_cur_scene != CAMERA_SCENE_MODE_FIREWORK) ||
+		    (s_cur_scene != CAMERA_SCENE_MODE_PARTY) ||
+		    (s_cur_scene != CAMERA_SCENE_MODE_SPORTS)) {
+			SENSOR_PRINT_HIGH("workaround: Reapplying ISO settings");
+			_s5k4ec_set_iso(s_ISO_mode);
+		}
+
+#if defined(WA_BOOST_DDR_FREQ_720P) || defined(WA_LIMIT_HD_CAM_24FPS)
+		s_fps_cur_mode = FPS_MODE_INVALID;
+
+		if (s_hd_applied) {
+#ifdef WA_BOOST_DDR_FREQ_720P
+			if (s_ddr_boosted == 0) {
+				if (s5k4ec_ddr_is_slow(1) == 0) {
+					SENSOR_PRINT_HIGH("workaround: Increasing DDR freq for 720p recording");
+				} else {
+					SENSOR_PRINT_HIGH("Failed to apply workaround, video may be more choppy");
+				}
+			}
+#endif
+#ifdef WA_LIMIT_HD_CAM_24FPS
+			SENSOR_PRINT_HIGH("workaround: s_target_max_fps %u", s_target_max_fps);
+			if ((s_target_max_fps > 24) || (s_target_max_fps == 0)) {
+				if (!s_target_max_fps) // Auto FPS is requested
+					s5k4ec_set_manual_FPS(0, 24);
+				else
+					s5k4ec_set_FPS(24);
+
+				SENSOR_PRINT_HIGH("workaround: limiting maximum FPS to 24");
+				s_fps_cur_mode = FPS_MODE_OVERRIDE;
+			}
+#endif
+		}
+#endif
+
+		// Apply the settings that tweaks the maximum Exposure time
+		// only for the scenes that don't change it.
+		if ((s_cur_scene != CAMERA_SCENE_MODE_NIGHT &&
+		     s_cur_scene != CAMERA_SCENE_MODE_FIREWORK) &&
+		     s_fps_cur_mode != FPS_MODE_OVERRIDE) {
+			s5k4ec_set_FPS(s_target_max_fps);
+		}
+
+		/*
+		 * Force unlock both AE and AWB on Stream On
+		 * Sometimes the AE/AWB lock gets stuck without being released
+		 * Due to some unforeseeable events (e.g. errors, OOM killer).
+		 */
+		s5k4ec_set_ae_awb_enable(1);
 	} else {
 		SENSOR_PRINT_HIGH("zxdbg capture stream on");
+
 		s5k4ec_I2C_write(s5k4ec_capture_start);
 	}
 
-	return 0;
+	s_stream_is_on = 1;
+	return SENSOR_SUCCESS;
 }
 
+LOCAL uint32_t _s5k4ec_StreamOff(__attribute__((unused)) uint32_t param)
+{
+	struct camera_context *cxt = camera_get_cxt();
+
+	SENSOR_PRINT_HIGH("Stop");
+
+#ifdef WA_BOOST_DDR_FREQ_720P
+	if (s_ddr_boosted)
+		s5k4ec_ddr_is_slow(0);
+#endif
+
+	s_flash_state = cxt->cmr_set.flash;
+	if ((s_cur_scene == CAMERA_SCENE_MODE_NIGHT ||
+	     s_cur_scene == CAMERA_SCENE_MODE_FIREWORK ||
+	     s_cur_scene == CAMERA_SCENE_MODE_HDR)) {
+
+		if (cxt->cmr_set.flash) {
+			cxt->cmr_set.flash = 0;
+			SENSOR_PRINT_HIGH("Flash is forced-disabled on the current scene mode.");
+		}
+	} else if ((FLASH_CLOSE != s_flash_state) && s_stream_is_on) {
+		s5k4ec_main_flash(1);
+	}
+
+	/*
+	 * Work around: Allow setting the scene mode again by invalidating the state
+	 * Some camera apps apply user settings (even the default)
+	 * after applying the scene modes that was meant to override
+	 * those user knobs once.
+	 */
+	s_cur_scene = (uint16_t) -1;
+
+	s_stream_is_on = 0;
+	return SENSOR_SUCCESS;
+}
 
 LOCAL uint32_t s5k4ec_I2C_write(SENSOR_REG_T* sensor_reg_ptr)
 {
@@ -1597,50 +1982,75 @@ LOCAL uint32_t s5k4ec_I2C_write(SENSOR_REG_T* sensor_reg_ptr)
 	Sensor_SendRegTabToSensor(&infotab);
 
 
-	 return 0;
+	return 0;
 }
 
 LOCAL uint32_t s5k4ec_set_Metering(uint32_t metering_mode)
 {
-	if(metering_mode >= 3) {
+	const char *str = "";
+
+	if(metering_mode >= CAMERA_AE_MODE_MAX) {
 		SENSOR_PRINT_ERR("Undefined Metering mode %u", metering_mode);
 		return SENSOR_OP_PARAM_ERR;
 	}
 
 	switch(metering_mode) {
-		case 0:
+		case CAMERA_AE_FRAME_AVG:
 			s5k4ec_I2C_write(s5k4ec_metering_matrix);
+			str = "Matrix";
 			break;
-		case 1:
-			s5k4ec_I2C_write(s5k4ec_metering_spot);
-			break;
-		case 2:
+		case CAMERA_AE_CENTER_WEIGHTED:
 			s5k4ec_I2C_write(s5k4ec_metering_center_weighted);
+			str = "Center Weighted";
+			break;
+		case CAMERA_AE_SPOT_METERING:
+			s5k4ec_I2C_write(s5k4ec_metering_spot);
+			str = "Spot";
 			break;
 	}
 
-	SENSOR_PRINT_HIGH(
-		"Apply %s Metering mode ",
-		0 == metering_mode ? "Matrix" :
-		1 == metering_mode ? "Spot" :
-		"Center Weighted"
-	);
+	SENSOR_PRINT_HIGH("Apply %s Metering mode ", str);
 	s_metering_mode = metering_mode;
 
-	return 0;
+	return SENSOR_SUCCESS;
 }
 
 LOCAL uint32_t s5k4ec_set_sharpness(uint32_t level)
 {
-	if(level >= 8) {
+	if(level >= 7) {
 		SENSOR_PRINT_ERR("Undefined Sharpness level %u", level);
 		return SENSOR_OP_PARAM_ERR;
 	}
 
 	SENSOR_PRINT_HIGH("Apply Sharpness level %u", level);
-	s5k4ec_I2C_write((SENSOR_REG_T*) s5k4ec_saturation_tab[level]);
 
-	return 0;
+	switch(level) {
+	case 0:
+		s5k4ec_I2C_write(s5k4ec_sharpness_minus_3);
+		break;
+	case 1:
+		s5k4ec_I2C_write(s5k4ec_sharpness_minus_2);
+		break;
+	case 2:
+		s5k4ec_I2C_write(s5k4ec_sharpness_minus_1);
+		break;
+	case 4:
+		s5k4ec_I2C_write(s5k4ec_sharpness_plus_1);
+		break;
+	case 5:
+		s5k4ec_I2C_write(s5k4ec_sharpness_plus_2);
+		break;
+	case 6:
+		s5k4ec_I2C_write(s5k4ec_sharpness_plus_3);
+		break;
+	default:
+	case 3:
+		s5k4ec_I2C_write(s5k4ec_sharpness_default);
+		break;
+	}
+
+	s_sharpness_lvl = (int32_t) level;
+	return SENSOR_SUCCESS;
 
 }
 
@@ -1649,15 +2059,13 @@ LOCAL uint32_t s5k4ec_lightcheck()
 	uint16_t low_word = 0;
 	uint16_t high_word = 0;
 
-
 	Sensor_WriteReg(0xFCFC,0xD000);
 	Sensor_WriteReg(0x002C, 0x7000);
 	Sensor_WriteReg(0x002E, 0x2C18);
 	low_word = Sensor_ReadReg(0x0F12);
-	Sensor_WriteReg(0x002E, 0x2C1A);
 	high_word = Sensor_ReadReg(0x0F12);
 
-	SENSOR_PRINT_HIGH("Luminance results high=%x low=%x", low_word, high_word);
+	SENSOR_PRINT_HIGH("Luminance results high=%x low=%x", high_word, low_word);
 
 	return low_word | (high_word <<16);
 
@@ -1666,13 +2074,14 @@ LOCAL uint32_t s5k4ec_lightcheck()
 LOCAL uint32_t s5k4ec_flash(uint32_t param)
 {
 	uint32_t *autoflash = (uint32_t *)param;
+	struct camera_context *cxt = camera_get_cxt();
 	uint32_t lux;
 
 	SENSOR_PRINT_HIGH("Start");
 
 	lux = s5k4ec_lightcheck();
 	if (LIGHT_STATUS_IS_LOW(lux)) {
-		SENSOR_PRINT_HIGH("Low light, using flash");
+		SENSOR_PRINT_HIGH("Low light, may use flash");
 		(*autoflash) = 1;
 	} else {
 		SENSOR_PRINT_HIGH("Normal light levels, not using flash");
@@ -1685,37 +2094,43 @@ LOCAL uint32_t s5k4ec_flash(uint32_t param)
 
 LOCAL uint32_t s5k4ec_get_ISO_rate(void)
 {
-	uint16_t iso_a_gain= 0;
-	uint16_t iso_d_gain= 0;
+	uint16_t iso_a_gain = 0;
+	uint16_t iso_d_gain = 0;
 	uint32_t iso_gain, iso_rate;
 
 	SENSOR_PRINT_HIGH("Get ISO gain");
 
+	// These registers output a fixed point number, 8.8 format
 	Sensor_WriteReg(0x002C, 0x7000);
 	Sensor_WriteReg(0x002E, 0x2BC4);
-	iso_a_gain = Sensor_ReadReg(0x00F12);
-	// Sensor_WriteReg(0x002E, 0x2BC6);
-	iso_d_gain = Sensor_ReadReg(0x00F12);
+	iso_a_gain = Sensor_ReadReg(0x00F12); // Mon_AAIO_PrevAcqCtxt_ME_AGain
+	iso_d_gain = Sensor_ReadReg(0x00F12); // Mon_AAIO_PrevAcqCtxt_ME_DGain
+
 
-	iso_gain = (iso_a_gain * iso_d_gain) / 384 /*200*/;
+	iso_gain = (iso_a_gain * iso_d_gain) / 400 /*384*/ /*200*/;
+
+	if (!iso_gain) {
+		SENSOR_PRINT_ERR("Failed. [ISO rate: 50 gain: %u]", iso_gain);
+		return 50;
+	}
 
 	/* Convert ISO value */
-	if(iso_gain > 0x400)
+	if(iso_gain > 0x400) {
 		iso_rate = 400;
-	else if(iso_gain > 0x200)
+	} else if(iso_gain > 0x200) {
 		iso_rate = 200;
-	else if(iso_gain > 0x100)
+	} else if(iso_gain > 0x100) {
 		iso_rate = 100;
-	else
+	} else {
 		iso_rate = 50;
+	}
 
+	SENSOR_PRINT_ERR("Analog gain: %f Digital Gain: %f]", (float) iso_a_gain/256, (float) iso_d_gain/256);
+	SENSOR_PRINT_ERR("Multiplied Gain: %f]", (float)(iso_a_gain * iso_d_gain) / (65536));
+	SENSOR_PRINT_ERR("Effective ISO value: %f, Sensor ISO value: %f", ((float)(iso_a_gain * iso_d_gain) / (65536)) * 50, ((float)iso_a_gain/256) * 50);
 
-	if (!iso_gain)
-		SENSOR_PRINT_ERR("Failed. [ISO rate:%u gain: %u]", iso_rate, iso_gain);
-	else
-		SENSOR_PRINT_HIGH("Done. [ISO rate:%u gain: %u]", iso_rate, iso_gain);
-
-	return iso_rate;
+	SENSOR_PRINT_HIGH("Done. [Simplified ISO rate:%u A*Dgain: %u]", iso_rate, iso_gain);
+	return ((iso_a_gain * iso_d_gain * 50) / (65536));
 }
 
 LOCAL uint32_t s5k4ec_get_shutter_speed(void)
@@ -1727,11 +2142,8 @@ LOCAL uint32_t s5k4ec_get_shutter_speed(void)
 
 	Sensor_WriteReg(0xFCFC, 0xD000);
 	Sensor_WriteReg(0x002C, 0x7000);
-
 	Sensor_WriteReg(0x002E, 0x2BC0);
 	lsb = Sensor_ReadReg(0x00F12);
-
-	Sensor_WriteReg(0x002E, 0x2BC2);
 	msb = Sensor_ReadReg(0x00F12);
 
 	/*
@@ -1739,27 +2151,21 @@ LOCAL uint32_t s5k4ec_get_shutter_speed(void)
 	 * x = ((msb << 16) | lsb) / 400
 	 * shutter_speed = 1000 / x
 	 */
-	exposure_time = (msb << 16) | lsb;
+	exposure_time = ((msb << 16) | lsb);
 
 	if (!exposure_time) {
 		SENSOR_PRINT_HIGH("Failed, sensor values are 0");
 		return 0;
-	} else {
-		exposure_time = 400000 / exposure_time;
-		if (!exposure_time) {
-			SENSOR_PRINT_HIGH("exposure time still results to 0");
-			exposure_time = 1;
-		}
 	}
 
-	SENSOR_PRINT_HIGH("Done. [Shutter Speed : %u]", exposure_time);
+	SENSOR_PRINT_HIGH("Done. Shutter Speed : %u [1/400 msec] (%f msec)", exposure_time, (float)exposure_time/400);
 	return exposure_time;
 }
 
 LOCAL uint16_t s5k4ecgx_get_frame_time()
 {
 	uint16_t frame_time = 0;
-	uint16_t temp1 = 0;
+	uint16_t msb, lsb;
 	int err;
 
 	SENSOR_PRINT_HIGH("Start");
@@ -1768,10 +2174,12 @@ LOCAL uint16_t s5k4ecgx_get_frame_time()
 	Sensor_WriteReg(0x002C, 0x7000);
 
 	Sensor_WriteReg(0x002E, 0x2128);
-	temp1 = Sensor_ReadReg (0x0F12);
+	lsb = Sensor_ReadReg (0x0F12);
+	msb = Sensor_ReadReg (0x0F12);
 
-	frame_time = temp1/400;
+	frame_time = (lsb | (msb << 16)) / 400;
 
+	SENSOR_PRINT_HIGH("Done. [Frame Time: lsb 0x%02X msb 0x%02X]", lsb , msb);
 	SENSOR_PRINT_HIGH("Done. [Frame Time: %u]",frame_time);
 
 	return frame_time;
@@ -1790,26 +2198,60 @@ LOCAL uint32_t __s5k4ecgx_set_focus_mode(uint32_t mode)
 
 	delay = s5k4ecgx_get_frame_time();
 
-	if (2 == mode) { //Macro
+	if ((mode != s_focus_mode) && ((s_focus_mode != 5) || (s_focus_mode != 4)))
+		s5k4ec_I2C_write(s5k4ec_AF_revert_continuous_mode);
+
+
+	switch(mode) {
+	case 2: // Macro
+		// Cancel CAF first
+		if ((s_focus_mode != 5) || (s_focus_mode != 4)) {
+			s5k4ec_I2C_write(s5k4ec_AF_normal_mode_2);
+			SENSOR_Sleep(delay);
+		}
+
 		s5k4ec_I2C_write(s5k4ec_AF_macro_mode_1);
 		SENSOR_Sleep(delay);
 
 		s5k4ec_I2C_write(s5k4ec_AF_macro_mode_2);
 		SENSOR_Sleep(delay);
 
-		s5k4ec_I2C_write(s5k4ec_AF_macro_mode_3);
-// 	} else if (3 == mode) { // Infinity
-// 		s5k4ec_I2C_write(s5k4ec_AF_return_inf_pos);
-	} else { // Auto and every other else
+		if (s_cur_scene != CAMERA_SCENE_MODE_NIGHT)
+			s5k4ec_I2C_write(s5k4ec_AF_macro_mode_3);
+		break;
+	case 3: // Infinity
+		s5k4ec_I2C_write(s5k4ec_AF_off_1);
+		break;
+	case 5: // Continuous AF for video
+		// Reset AF Window
+		_s5k4ecgx_reset_focus_touch_position();
+		/* Fall-through */
+	case 4: // Continuous AF for picture
+		s5k4ec_I2C_write(s5k4ec_AF_continuous_mode_1);
+		SENSOR_Sleep(delay);
+
+		if (s_cur_scene != CAMERA_SCENE_MODE_NIGHT)
+			s5k4ec_I2C_write(s5k4ec_AF_continuous_mode_2);
+
+		s5k4ec_I2C_write(s5k4ec_continuous_AF_start);
+		SENSOR_Sleep(2 * delay);
+
+		break;
+	// For everything else, use the normal AF
+	default:
 		s5k4ec_I2C_write(s5k4ec_AF_normal_mode_1);
 		SENSOR_Sleep(delay);
 
 		s5k4ec_I2C_write(s5k4ec_AF_normal_mode_2);
 		SENSOR_Sleep(delay);
 
-		s5k4ec_I2C_write(s5k4ec_AF_normal_mode_3);
+		if (s_cur_scene != CAMERA_SCENE_MODE_NIGHT)
+			s5k4ec_I2C_write(s5k4ec_AF_normal_mode_3);
+		break;
 	}
-	return 0;
+
+	s_focus_mode = mode;
+	return SENSOR_SUCCESS;
 }
 
 LOCAL uint32_t s5k4ecgx_set_focus_mode(uint32_t mode)
@@ -1852,11 +2294,15 @@ LOCAL uint32_t s5k4ec_wait_until_ae_stable()
 			}
 
 			SENSOR_PRINT_HIGH("Recheck AE status: %u, expected %d", reg_value, ph);
-			SENSOR_Sleep(10);
+
+			if (s_fast_ae_en)
+				SENSOR_Sleep(1);
+			else
+				SENSOR_Sleep(10);
 		}
 	}
 	SENSOR_PRINT_HIGH("Done.");
-	return 0;
+	return SENSOR_SUCCESS;
 }
 
 LOCAL uint32_t s5k4ec_preflash_af(uint32_t on)
@@ -1867,7 +2313,7 @@ LOCAL uint32_t s5k4ec_preflash_af(uint32_t on)
 	else
 		s5k4ec_I2C_write(s5k4ec_pre_flash_Off);
 
-	return 0;
+	return SENSOR_SUCCESS;
 }
 
 LOCAL uint32_t s5k4ecgx_fast_ae(uint32_t on)
@@ -1877,8 +2323,9 @@ LOCAL uint32_t s5k4ecgx_fast_ae(uint32_t on)
 		s5k4ec_I2C_write(s5k4ec_FAST_AE_On);
 	else
 		s5k4ec_I2C_write(s5k4ec_FAST_AE_Off);
+	s_fast_ae_en = on;
 
-	return 0;
+	return SENSOR_SUCCESS;
 }
 
 LOCAL uint32_t s5k4ec_main_flash(uint32_t on)
@@ -1892,6 +2339,16 @@ LOCAL uint32_t s5k4ec_main_flash(uint32_t on)
 	return SENSOR_SUCCESS;
 }
 
+/*
+ * Low light AF - Reduce AF lens posiiton table
+ * The AF algorithm requires a number of the actual preview frames
+ * to compute its sharpness statistics.
+ * On low light conditions, preview framerate tends to be reduced,
+ * thus causing a longer AF search time.
+ *
+ * Low light AF will almost halve the table which should give
+ * some considerable speed up on the aforementioned scenario.
+ */
 LOCAL uint32_t s5k4ec_low_light_AF_check(void)
 {
 	struct camera_context *cxt = camera_get_cxt();
@@ -1900,29 +2357,41 @@ LOCAL uint32_t s5k4ec_low_light_AF_check(void)
 
 	SENSOR_PRINT_HIGH("Decide whether to use low light AF or not");
 
-	/*
-	 * The conditions for low light AF is that the conditions
-	 * are considered low light and Flash is will never be used
-	 */
-	if ((flash_mode == FLASH_CLOSE) && LIGHT_STATUS_IS_LOW(s5k4ec_lightcheck())) {
+	if (s_cur_scene == CAMERA_SCENE_MODE_NIGHT) {
+		SENSOR_PRINT_HIGH("Night Scene mode only uses low light AF.");
+		return SENSOR_SUCCESS;
+	}
+
+	if ((flash_mode == FLASH_CLOSE) && (s5k4ecgx_get_frame_time() > 67))
 		use_ll_af = 1;
-		SENSOR_PRINT_HIGH("Using low light autofocus");
-	} else {
+	else
 		use_ll_af = 0;
-		SENSOR_PRINT_HIGH("Not using low light autofocus");
-	}
 
 	if (use_ll_af == s_using_low_light_af) {
-		SENSOR_PRINT_HIGH("Sensor already%s using Low light autofocus",
+		SENSOR_PRINT_HIGH(
+			"Sensor already%s using Low light autofocus",
 			use_ll_af ? "" : " not"
 		);
 		return SENSOR_SUCCESS;
+	} else {
+		SENSOR_PRINT_HIGH("Will %s low light autofocus", use_ll_af ? "apply" : "revert");
 	}
 
-	if (use_ll_af)
+	if (use_ll_af) {
 		s5k4ec_I2C_write(s5k4ec_AF_low_light_mode_On);
-	else
-		s5k4ec_I2C_write(s5k4ec_AF_low_light_mode_Off);
+
+		// Reverse the direction when on Macro mode
+		if (s_focus_mode == 2) // Macro
+			s5k4ec_I2C_write(s5k4ec_AF_low_light_macro_mode);
+	} else {
+		if (s_focus_mode == 2) { // Macro
+			s5k4ec_I2C_write(s5k4ec_AF_macro_mode_3);
+		} else if ((s_focus_mode == 5) || (s_focus_mode == 4)) { // CAF
+			s5k4ec_I2C_write(s5k4ec_AF_continuous_mode_2);
+		} else { // Normal AF
+			s5k4ec_I2C_write(s5k4ec_AF_normal_mode_3);
+		}
+	}
 
 	SENSOR_PRINT_HIGH("Done.");
 	return SENSOR_SUCCESS;
@@ -1932,36 +2401,34 @@ LOCAL uint32_t s5k4ec_set_FPS_mode(uint32_t fps_mode)
 {
 	SENSOR_PRINT_HIGH("Apply FPS mode %d", fps_mode);
 
-	if (s_fps_cur_max == fps_mode) {
-		SENSOR_PRINT_HIGH("Already applied");
-		return SENSOR_SUCCESS;
-	}
-
 	switch(fps_mode) {
-		case 0:
-			s5k4ec_I2C_write(s5k4ec_Auto30_FPS);
-			break;
-		case 1:
-			s5k4ec_I2C_write(s5k4ec_7_FPS);
-			break;
-		case 2:
-			s5k4ec_I2C_write(s5k4ec_12_FPS);
-			break;
-		case 3:
-			s5k4ec_I2C_write(s5k4ec_15_FPS);
-			break;
-		case 4:
-			s5k4ec_I2C_write(s5k4ec_30_FPS);
-			break;
-		case 5:
-			s5k4ec_I2C_write(s5k4ec_25_FPS);
-			break;
-		default:
-			SENSOR_PRINT_ERR("Undefined FPS mode %u", fps_mode);
-			return SENSOR_FAIL;
+	case FPS_MODE_AUTO:
+		s5k4ec_I2C_write(s5k4ec_Auto30_FPS);
+		break;
+	case FPS_MODE_7:
+		s5k4ec_I2C_write(s5k4ec_7_FPS);
+		break;
+	case FPS_MODE_12:
+		s5k4ec_I2C_write(s5k4ec_12_FPS);
+		break;
+	case FPS_MODE_15:
+		s5k4ec_I2C_write(s5k4ec_15_FPS);
+		break;
+	case FPS_MODE_24:
+		s5k4ec_I2C_write(s5k4ec_24_FPS);
+		break;
+	case FPS_MODE_25:
+		s5k4ec_I2C_write(s5k4ec_25_FPS);
+		break;
+	case FPS_MODE_30:
+		s5k4ec_I2C_write(s5k4ec_30_FPS);
+		break;
+	default:
+		SENSOR_PRINT_ERR("Undefined FPS mode %u", fps_mode);
+		return SENSOR_FAIL;
 	}
-	s_fps_cur_max = fps_mode;
-	SENSOR_Sleep(5);
+	s_fps_cur_mode = fps_mode;
+
 	return SENSOR_SUCCESS;
 }
 
@@ -1970,20 +2437,170 @@ LOCAL uint32_t s5k4ec_set_FPS(uint32_t fps)
 	uint32_t mode;
 
 	if (0 == fps) { /* Auto FPS */
-		mode = 0;
+		mode = FPS_MODE_AUTO;
 	} else if (7 >= fps) {
-		mode = 1;
+		mode = FPS_MODE_7;
 	} else if (12 >= fps) {
-		mode = 2;
+		mode = FPS_MODE_12;
 	} else if (15 >= fps) {
-		mode = 3;
+		mode = FPS_MODE_15;
+	} else if (24 >= fps) {
+		mode = FPS_MODE_24;
 	} else if (25 >= fps) {
-		mode = 4;
+		mode = FPS_MODE_25;
 	} else if (30 >= fps) {
-		mode = 5;
+		mode = FPS_MODE_30;
 	} else {
-		mode = 64; /* An invalid mode */
+		SENSOR_PRINT_HIGH("Unsupported fps %u", fps);
+		mode = FPS_MODE_INVALID; /* An invalid mode */
 	}
 
 	return s5k4ec_set_FPS_mode(mode);
 }
+
+LOCAL uint32_t s5k4ec_set_manual_FPS(uint32_t min, uint32_t max)
+{
+	uint16_t FrRateQualityType;
+	static SENSOR_REG_T manual_setting[] = {
+		{0x0028, 0x7000},
+
+		{0x002A, 0x02BE},
+		{0x0F12, 0x0000},
+		{0x0F12, 0x0000}, //3
+		{0x0F12, 0x0000}, //4
+		{0x0F12, 0x0000}, //5
+
+		{0x002A, 0x0266},
+		{0x0F12, 0x0000},
+		{0x002A, 0x026A},
+		{0x0F12, 0x0001},
+		{0x002A, 0x024E},
+		{0x0F12, 0x0001},
+		{0x002A, 0x0268},
+		{0x0F12, 0x0001},
+		{0xFFFF, 0xFFFF},
+	};
+
+	SENSOR_PRINT_ERR("Max:%u Min:%u", max, min);
+
+	if ((30 < max) || (30 > min) || (min > max)) {
+		SENSOR_PRINT_ERR("Invalid options passed.");
+		return -1;
+	}
+
+	if (min == max)
+		FrRateQualityType = 1;
+	else
+		FrRateQualityType = 0;
+
+	manual_setting[3].reg_value = FrRateQualityType;
+	manual_setting[4].reg_value = max;
+	manual_setting[5].reg_value = min;
+
+	s5k4ec_I2C_write(manual_setting);
+
+	s_fps_cur_mode = FPS_MODE_MANUAL;
+	return SENSOR_SUCCESS;
+}
+
+LOCAL void s5k4ec_set_REG_TC_DBG_AutoAlgEnBits(int bit, int set)
+{
+	uint16_t REG_TC_DBG_AutoAlgEnBits = 0;
+	static SENSOR_REG_T reg_set[] = {
+		{0xFCFC, 0xD000},
+		{0x0028, 0x7000},
+		{0x002A, 0x04E6},
+		{0x0F12, 0x077F},// 3
+		{0xFFFF, 0xFFFF},
+	};
+
+	Sensor_WriteReg(0x002C, 0x7000);
+	Sensor_WriteReg(0x002E, 0x04E6);
+	REG_TC_DBG_AutoAlgEnBits = Sensor_ReadReg(0x0F12);
+
+	SENSOR_PRINT_HIGH ("REG_TC_DBG_AutoAlgEnBits before: 0x%X", REG_TC_DBG_AutoAlgEnBits);
+	if (set) {
+		if (REG_TC_DBG_AutoAlgEnBits & (1 << bit)) {
+			SENSOR_PRINT_HIGH ("No need to set");
+			return;
+		}
+
+		REG_TC_DBG_AutoAlgEnBits |= (1 << bit);
+	} else {
+		if (!(REG_TC_DBG_AutoAlgEnBits & (1 << bit))) {
+			SENSOR_PRINT_HIGH ("No need to unset");
+			return;
+		}
+
+		REG_TC_DBG_AutoAlgEnBits &= ~(1 << bit);
+	}
+	reg_set[3].reg_value = REG_TC_DBG_AutoAlgEnBits;
+
+	SENSOR_PRINT_HIGH ("REG_TC_DBG_AutoAlgEnBits after: 0x%X", REG_TC_DBG_AutoAlgEnBits);
+
+	s5k4ec_I2C_write(reg_set);
+	return;
+}
+
+#ifdef WA_BOOST_DDR_FREQ_720P
+LOCAL int8_t s5k4ec_ddr_is_slow(int8_t boost) {
+	/*
+	 * We could do two things as a workaround:
+	 * 1. Disable DFS and clamp to the highest frequency using set_freq
+	 * 2. Tweak the thresholds using set_upthreshold
+	 *    of SPRD's ondemand governor to make it
+	 *    more sensitive to load changes.
+	 * #1 is the simplest but have the tendency to clamp it there
+	 * forever until someone fixes it, when an error occurs.
+	 * #2 on errors, will still have the DFS on and may
+	 * still scale down. It's just more likely to scale up.
+	 *
+	 * I'll use the #2.
+	 */
+	// const char* const set_freq = "/sys/devices/platform/scxx30-dmcfreq.0/devfreq/scxx30-dmcfreq.0/ondemand/set_freq";
+	const char* const set_upthreshold = "/sys/class/devfreq/scxx30-dmcfreq.0/ondemand/set_upthreshold";
+	const char* const threshold = "50";
+
+	static char prev_thresh[5] = {0};
+	int ret;
+	FILE* fp;
+
+	SENSOR_PRINT_HIGH("boost=%d", boost);
+
+	if (s_ddr_boosted == boost)
+		return 0;
+
+	SENSOR_PRINT_HIGH("Open file %s", set_upthreshold);
+	if (!(fp = fopen(set_upthreshold, "r+"))) {
+		SENSOR_PRINT_ERR("Failed to open %s", set_upthreshold);
+		return -1;
+	}
+
+	// method #1
+	// fprintf(fp, "%d", boost ? 500000: 0); //one-liner
+
+	//method #2
+	if (boost) {
+		prev_thresh[0] = 0;
+		if (fgets(prev_thresh, 5 /*sizeof(prev_thresh)*/, fp)) {
+			ret = fprintf(fp, "%s", threshold);
+		} else {
+			SENSOR_PRINT_ERR("Error reading file: %s", strerror(errno));
+			ret = -1;
+			goto close_file;
+		}
+	} else {
+		ret = fprintf(fp, "%s", prev_thresh);
+	}
+
+	if (ret < 0) {
+		SENSOR_PRINT_HIGH("Error writing to file: %s", strerror(errno));
+	} else {
+		s_ddr_boosted = boost;
+	}
+
+close_file:
+	fclose(fp);
+	return ret;
+}
+#endif
diff --git a/libcamera/scx15/sensor/sensor_s5k4ecgx_regs_mipi.h b/libcamera/scx15/sensor/sensor_s5k4ecgx_regs_mipi.h
index df20896..a43d7ff 100644
--- a/libcamera/scx15/sensor/sensor_s5k4ecgx_regs_mipi.h
+++ b/libcamera/scx15/sensor/sensor_s5k4ecgx_regs_mipi.h
@@ -17,7 +17,7 @@
 //#include "../sc8830/inc/SprdCameraHardwareConfig.h"
 
 
-/* Enum Type for different ISO Mode supported */
+/* Enum for different ISO Mode supported */
 enum {
 	CAMERA_ISO_AUTO = 0,
 	CAMERA_ISO_100,
@@ -27,9 +27,11 @@ enum {
 	CAMERA_ISO_1600,
 	CAMERA_ISO_50,
 	CAMERA_ISO_300,
+	CAMERA_ISO_600,
 	CAMERA_ISO_MAX
 };
 
+/* Enum for different Scene modes used in SPRD libcamera */
 enum {
 	CAMERA_SCENE_MODE_AUTO = 0,
 	CAMERA_SCENE_MODE_NIGHT,
@@ -52,7 +54,39 @@ enum {
 	CAMERA_SCENE_MODE_MAX
 };
 
+/* Enum for the AE metering modes used in SPRD libcamera */
+enum {
+	CAMERA_AE_FRAME_AVG = 0,
+	CAMERA_AE_CENTER_WEIGHTED,
+	CAMERA_AE_SPOT_METERING,
+	CAMERA_AE_MODE_MAX
+};
+
+/* Enum for the anti flicker modes used in SPRD libcamera */
+enum {
+	CAMERA_ANTIBANDING_50HZ,
+	CAMERA_ANTIBANDING_60HZ,
+	CAMERA_ANTIBANDING_OFF,
+	CAMERA_ANTIBANDING_AUTO,
+	CAMERA_MAX_ANTIBANDING,
+};
 
+/* Enum for the bits in REG_TC_DBG_AutoAlgEnBits */
+enum {
+	AA_ALL,             // 0
+	AA_AE_ACTIVE,       // 1
+	AA_DIV_LEI,         // 2
+	AA_WB_ACTIVE,       // 3
+                            //
+	AA_USE_WB_FOR_ISP,  // 4
+	AA_FLICKER,         // 5
+	AA_FIT,             // 6
+                            //
+	AA_7, // unused     // 7
+	AA_8, // unused     // 8
+	AA_WR_ISP_HW,       // 9
+	AA_WR_SEN_HW,       // 10
+};
 //==========================================================
 // Init
 //==========================================================
@@ -2039,12 +2073,11 @@ LOCAL SENSOR_REG_T s5k4ec_common_init[] = {
 
 	{0x002A, 0x164C},
 	{0x0F12, 0x0003},
-	{0x002A, 0x163E},
 
-	// {0x0F12, 0x00D5},
-	// {0x0F12, 0x0080},   //98(60%) -> CC(80%)
-	{0x0F12, 0x00C2},
-	{0x0F12, 0x0098},   //98(60%) -> CC(80%)
+
+	{0x002A, 0x163E},   // thresholds in 8.8 format: 98(60%) -> C2(75%)
+	{0x0F12, 0x00C2},   //af_search_usPeakThr
+	{0x0F12, 0x0098},   //af_search_usPeakThrLow
 
 
 	{0x002A, 0x15D4},
@@ -2066,9 +2099,9 @@ LOCAL SENSOR_REG_T s5k4ec_common_init[] = {
 	{0x0F12, 0x0010},
 	{0x002A, 0x1656},
 	{0x0F12, 0x0000},
+
 	{0x002A, 0x15E6},
 	{0x0F12, 0x003C},
-
 	{0x0F12, 0x0018},   //af_pos_usTableLastInd
 	{0x0F12, 0x002A},
 	{0x0F12, 0x0030},
@@ -2105,10 +2138,10 @@ LOCAL SENSOR_REG_T s5k4ec_common_init[] = {
 
 	// {0x0F12, 0x0003},   //delay2 when threshold upper lens moving when moving distance 9 delay 80h 12.8ms delay
 	{0x0F12, 0x0008},   // delay2 ??
-
 	{0x0F12, 0x0001},   //threshold
-	{0x0F12, 0x0004},   //delay1 ??
-	{0x0F12, 0x0080},
+
+	{0x0F12, 0x0004},   // signal shaping
+	{0x0F12, 0x0080},   // signal shaping levels
 	{0x0F12, 0x00C0},
 	{0x0F12, 0x00E0},
 	{0x0F12, 0x0000},
@@ -2541,19 +2574,17 @@ LOCAL SENSOR_REG_T s5k4ec_common_init[] = {
 	{0x0F12, 0xC350},		//C350
 	{0x0F12, 0x0000},		//0000
 
-	//???
 	{0x002A, 0x0660},
-	{0x0F12, 0x0650},
-	{0x0F12, 0x0100},
+	{0x0F12, 0x0650}, //lt_ExpGain_ExpCurveGainMaxStr_1_
+	{0x0F12, 0x0100}, //lt_ExpGain_ExpCurveGainMaxStr_1__uMaxDigGain
 
 	// Lei Control
 	{0x002A, 0x06B8},
 	{0x0F12, 0x452C},
 	{0x0F12, 0x0005},	 //lt_uMaxLei
 
-	//?????
 	{0x002A, 0x05D0},
-	{0x0F12, 0x0000},
+	{0x0F12, 0x0000}, //lt_mbr_Peak_behind
 
 	//==================================================================================
 	// 13.AE Weight (Normal)
@@ -3628,61 +3659,191 @@ LOCAL SENSOR_REG_T s5k4ec_common_init[] = {
 
 //==========================================================
 // ISO
+// NOTE: These reg settings came from stock. Except that
+//       these will not change the anti-flicker settings
+// NOTE: Manual ISO settings will DISABLE the Digital gain
+//       (or the so called Extended ISOs).
 //==========================================================
 LOCAL SENSOR_REG_T  s5k4ec_ISO_auto[] = {
+	{0xFCFC, 0xD000},
 	{0x0028, 0x7000},
-	{0x002A ,0x04D0},
-	{0x0F12 ,0x0000},
-	{0x0F12 ,0x0000},
-	{0x0F12 ,0x0001},
+
+	{0x002A, 0x0938},
+	{0x0F12, 0x0000},	//afit_bUseNB_Afit
+	{0x0F12, 0x0014},	//SARR_uNormBrInDoor_0_
+	{0x0F12, 0x00D2},	//SARR_uNormBrInDoor_1_
+	{0x0F12, 0x0384},	//SARR_uNormBrInDoor_2_
+	{0x0F12, 0x07D0},	//SARR_uNormBrInDoor_3_
+	{0x0F12, 0x1388},	//SARR_uNormBrInDoor_4_
+
+	{0x002A, 0x04D0},
+	{0x0F12, 0x0000}, // REG_SF_USER_IsoType: 0- Auto 1- Classic 2-Sport
+	{0x0F12, 0x0000}, // REG_SF_USER_IsoVal
+	{0x0F12, 0x0001}, // REG_SF_USER_IsoChanged
+
+	{0x002A, 0x06C2},
+	{0x0F12, 0x0200}, //lt_bUseSecISODgain
+
 	{0xFFFF, 0xFFFF}
 };
 
 LOCAL SENSOR_REG_T  s5k4ec_ISO_50[] = {
+	{0xFCFC, 0xD000},
 	{0x0028, 0x7000},
-	{0x002A ,0x04D0},
-	{0x0F12 ,0x0001},
-	{0x0F12 ,0x0100},
-	{0x0F12 ,0x0001},
+	{0x002A, 0x0938},
+	{0x0F12, 0x0001},	//afit_bUseNB_Afit
+	{0x0F12, 0x0014},	//SARR_uNormBrInDoor_0_
+	{0x0F12, 0x00D2},	//SARR_uNormBrInDoor_1_
+	{0x0F12, 0x0384},	//SARR_uNormBrInDoor_2_
+	{0x0F12, 0x07D0},	//SARR_uNormBrInDoor_3_
+	{0x0F12, 0x1388},	//SARR_uNormBrInDoor_4_
+
+	{0x002A, 0x04D0},
+	{0x0F12, 0x0001},	//REG_SF_USER_IsoType
+	{0x0F12, 0x0100},	//REG_SF_USER_IsoVal
+	{0x0F12, 0x0001},	//REG_SF_USER_IsoChanged
+
+	{0x002A, 0x06C2},
+	{0x0F12, 0x0100},	//lt_bUseSecISODgain
 	{0xFFFF, 0xFFFF}
 };
 
 LOCAL SENSOR_REG_T  s5k4ec_ISO_100[] = {
+	{0xFCFC, 0xD000},
 	{0x0028, 0x7000},
-	{0x002A ,0x04D0},
-	{0x0F12 ,0x0001},
-	{0x0F12 ,0x01A0},
-	{0x0F12 ,0x0001},
+	{0x002A, 0x0938},
+	{0x0F12, 0x0001},	//afit_bUseNB_Afit
+	{0x0F12, 0x0014},	//SARR_uNormBrInDoor_0_
+	{0x0F12, 0x00D2},	//SARR_uNormBrInDoor_1_
+	{0x0F12, 0x0384},	//SARR_uNormBrInDoor_2_
+	{0x0F12, 0x07D0},	//SARR_uNormBrInDoor_3_
+	{0x0F12, 0x1388},	//SARR_uNormBrInDoor_4_
+
+	{0x002A, 0x04D0},
+	{0x0F12, 0x0001},	//REG_SF_USER_IsoType
+	{0x0F12, 0x01BA},	//REG_SF_USER_IsoVal
+	{0x0F12, 0x0001},	//REG_SF_USER_IsoChanged
+	{0x002A, 0x06C2},
+	{0x0F12, 0x0100},	//lt_bUseSecISODgain
+
 	{0xFFFF, 0xFFFF}
 };
 
 LOCAL SENSOR_REG_T  s5k4ec_ISO_200[] = {
+	{0xFCFC, 0xD000},
 	{0x0028, 0x7000},
-	{0x002A ,0x04D0},
-	{0x0F12 ,0x0001},
-	{0x0F12 ,0x0458},
-	{0x0F12 ,0x0001},
+	{0x002A, 0x0938},
+	{0x0F12, 0x0001},	//afit_bUseNB_Afit
+	{0x0F12, 0x0114},	//SARR_uNormBrInDoor_0_
+	{0x0F12, 0x04A2},	//SARR_uNormBrInDoor_1_
+	{0x0F12, 0x0584},	//SARR_uNormBrInDoor_2_
+	{0x0F12, 0x08D0},	//SARR_uNormBrInDoor_3_
+	{0x0F12, 0x1388},	//SARR_uNormBrInDoor_4_
+
+	{0x002A, 0x04D0},
+	{0x0F12, 0x0001},	//REG_SF_USER_IsoType
+	{0x0F12, 0x0374},	//REG_SF_USER_IsoVal
+	{0x0F12, 0x0001},	//REG_SF_USER_IsoChanged
+	{0x002A, 0x06C2},
+	{0x0F12, 0x0100},	//lt_bUseSecISODgain
+
 	{0xFFFF, 0xFFFF}
 };
 
+LOCAL SENSOR_REG_T  s5k4ec_ISO_400[] = {
+	{0xFCFC, 0xD000},
+	{0x0028, 0x7000},
+
+	{0x002A, 0x0938},
+	{0x0F12, 0x0001},	//afit_bUseNB_Afit
+	{0x0F12, 0x0214},	//SARR_uNormBrInDoor_0_
+	{0x0F12, 0x0BD2},	//SARR_uNormBrInDoor_1_
+	{0x0F12, 0x0C84},	//SARR_uNormBrInDoor_2_
+	{0x0F12, 0x10D0},	//SARR_uNormBrInDoor_3_
+	{0x0F12, 0x1388},	//SARR_uNormBrInDoor_4_
+
+	{0x002A, 0x04D0},
+	{0x0F12, 0x0001},	//REG_SF_USER_IsoType
+	{0x0F12, 0x06F4},	//REG_SF_USER_IsoVal
+	{0x0F12, 0x0001},	//REG_SF_USER_IsoChanged
+
+	{0x002A, 0x06C2},
+	{0x0F12, 0x0100},	//lt_bUseSecISODgain
+
+	{0xFFFF, 0xFFFF}
+};
+
+// These reg settings are experimental
 LOCAL SENSOR_REG_T  s5k4ec_ISO_300[] = {
+	{0xFCFC, 0xD000},
+	{0x0028, 0x7000},
+
+	{0x002A, 0x0938},
+	{0x0F12, 0x0001},	//afit_bUseNB_Afit
+	{0x0F12, 0x0214},	//SARR_uNormBrInDoor_0_
+	{0x0F12, 0x0BD2},	//SARR_uNormBrInDoor_1_
+	{0x0F12, 0x0C84},	//SARR_uNormBrInDoor_2_
+	{0x0F12, 0x10D0},	//SARR_uNormBrInDoor_3_
+	{0x0F12, 0x1388},	//SARR_uNormBrInDoor_4_
+
+	{0x002A, 0x04D0},
+	{0x0F12, 0x0001},	//REG_SF_USER_IsoType
+	{0x0F12, 0x0534},	//REG_SF_USER_IsoVal
+	{0x0F12, 0x0001},	//REG_SF_USER_IsoChanged
+
+	{0x002A, 0x06C2},
+	{0x0F12, 0x0100},	//lt_bUseSecISODgain
+
+	{0xFFFF, 0xFFFF}
+};
+
+LOCAL SENSOR_REG_T  s5k4ec_ISO_600[] = {
+	{0xFCFC, 0xD000},
 	{0x0028, 0x7000},
-	{0x002A ,0x04D0},
-	{0x0F12 ,0x0001},
-	{0x0F12 ,0x0710},
-	{0x0F12 ,0x0001},
+
+	{0x002A, 0x0938},
+	{0x0F12, 0x0001},	//afit_bUseNB_Afit
+	{0x0F12, 0x0214},	//SARR_uNormBrInDoor_0_
+	{0x0F12, 0x0BD2},	//SARR_uNormBrInDoor_1_
+	{0x0F12, 0x0C84},	//SARR_uNormBrInDoor_2_
+	{0x0F12, 0x10D0},	//SARR_uNormBrInDoor_3_
+	{0x0F12, 0x1388},	//SARR_uNormBrInDoor_4_
+
+	{0x002A, 0x04D0},
+	{0x0F12, 0x0001},	//REG_SF_USER_IsoType
+	{0x0F12, 0x0C80},	//REG_SF_USER_IsoVal
+	{0x0F12, 0x0001},	//REG_SF_USER_IsoChanged
+
+	{0x002A, 0x06C2},
+	{0x0F12, 0x0100},	//lt_bUseSecISODgain
+
 	{0xFFFF, 0xFFFF}
 };
 
-LOCAL SENSOR_REG_T  s5k4ec_ISO_400[] = {
+LOCAL SENSOR_REG_T  s5k4ec_ISO_800[] = {
+	{0xFCFC, 0xD000},
 	{0x0028, 0x7000},
-	{0x002A ,0x04D0},
-	{0x0F12 ,0x0001},
-	{0x0F12 ,0x0C80},
-	{0x0F12 ,0x0001},
+
+	{0x002A, 0x0938},
+	{0x0F12, 0x0001},	//afit_bUseNB_Afit
+	{0x0F12, 0x0214},	//SARR_uNormBrInDoor_0_
+	{0x0F12, 0x0BD2},	//SARR_uNormBrInDoor_1_
+	{0x0F12, 0x0C84},	//SARR_uNormBrInDoor_2_
+	{0x0F12, 0x10D0},	//SARR_uNormBrInDoor_3_
+	{0x0F12, 0x1388},	//SARR_uNormBrInDoor_4_
+
+	{0x002A, 0x04D0},
+	{0x0F12, 0x0001},	//REG_SF_USER_IsoType
+	{0x0F12, 0x1680},	//REG_SF_USER_IsoVal
+	{0x0F12, 0x0001},	//REG_SF_USER_IsoChanged
+
+	{0x002A, 0x06C2},
+	{0x0F12, 0x0100},	//lt_bUseSecISODgain
+
 	{0xFFFF, 0xFFFF}
 };
 
+
 //==========================================================
 // Scenes (Alphabetically arranged)
 //==========================================================
@@ -3746,8 +3907,6 @@ LOCAL SENSOR_REG_T s5k4ec_scene_beach[] = {
 LOCAL SENSOR_REG_T s5k4ec_scene_candlelight[] = {
 	{0xFCFC, 0xD000},
 	{0x0028, 0x7000},
-	{0x002A, 0x04E6},
-	{0x0F12, 0x0777},
 	{0x0020, 0x04BA},
 	{0x0F10, 0x04DA},
 	{0x002A, 0x04BE},
@@ -3762,8 +3921,6 @@ LOCAL SENSOR_REG_T s5k4ec_scene_candlelight[] = {
 LOCAL SENSOR_REG_T s5k4ec_scene_dawn[] = {
 	{0xFCFC, 0xD000},
 	{0x0028, 0x7000},
-	{0x002A, 0x04E6},
-	{0x0F12, 0x0777},
 	{0x002A, 0x04BA},
 	{0x0F12, 0x0558},
 	{0x002A, 0x04BE},
@@ -3918,12 +4075,19 @@ LOCAL SENSOR_REG_T s5k4ec_scene_night[] = {
 	{0x0F12, 0x0006},
 	{0x0F12, 0x1A80},
 	{0x0F12, 0x0006},
-	{0x002A, 0x02C2},
+
+	{0x002A, 0x02BE},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0000},
 	{0x0F12, 0x07D0},
 	{0x0F12, 0x014A},
-	{0x002A, 0x03B4},
-	{0x0F12, 0x1388},
-	{0x0F12, 0x1388},
+
+	{0x002A, 0x03B0},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0002},
+	{0x0F12, 0x1964}, //1.5fps min
+	{0x0F12, 0x0000},
+
 	{0x002A, 0x1648},
 	{0x0F12, 0x9000},
 	{0x002A, 0x15E8},
@@ -4025,16 +4189,17 @@ LOCAL SENSOR_REG_T s5k4ec_scene_off[] = {
 	{0x0F12, 0x0000},
 	{0x0F12, 0xC350},
 	{0x0F12, 0x0000},
+
+// A separate reg setting might override this
 	{0x002A, 0x02C2},
 	{0x0F12, 0x029A},
 	{0x0F12, 0x014A},
 	{0x002A, 0x03B4},
 	{0x0F12, 0x0535},
 	{0x0F12, 0x029A},
+
 	{0x002A, 0x0938},
 	{0x0F12, 0x0000},
-	{0x002A, 0x04E6},
-	{0x0F12, 0x077F},
 	{0x002A, 0x1484},
 	{0x0F12, 0x003C},
 	{0x002A, 0x04D0},
@@ -4171,8 +4336,6 @@ LOCAL SENSOR_REG_T s5k4ec_scene_sports[] = {
 LOCAL SENSOR_REG_T s5k4ec_scene_sunset[] = {
 	{0xFCFC, 0xD000},
 	{0x0028, 0x7000},
-	{0x002A, 0x04E6},
-	{0x0F12, 0x0777},
 	{0x002A, 0x04BA},
 	{0x0F12, 0x04DA},
 	{0x002A, 0x04BE},
@@ -4200,6 +4363,151 @@ LOCAL SENSOR_REG_T s5k4ec_scene_text[] = {
 	{0xFFFF, 0xFFFF},
 };
 
+//==========================================================
+// Anti-Scenes
+// NOTE: These reg settings are pieces that could revert
+// some changes of a scene mode. These are used to avoid
+// firing CAMERA_SCENE_MODE_AUTO everytime a use has
+// to change scene. s5k4ec_scene_off has over 136 values
+// and takes few miliseconds to finish.
+// NOTE: Not just because some are named after their scene
+// means that they could fully revert the changes.
+// It just means that the reg setting came from that scene.
+//==========================================================
+LOCAL SENSOR_REG_T s5k4ec_scene_revert_sharpness0[] = {
+	{0xFCFC, 0xD000},
+	{0x0028, 0x7000},
+	{0x002A, 0x0A28},
+	{0x0F12, 0x6024},	//_ee_iLowSharpPower
+	{0x002A, 0x0ADE},
+	{0x0F12, 0x6024},	//_ee_iLowSharpPower
+	{0x002A, 0x0B94},
+	{0x0F12, 0x6024},	//_ee_iLowSharpPower
+	{0x002A, 0x0C4A},
+	{0x0F12, 0x6024},	//_ee_iLowSharpPower
+	{0x002A, 0x0D00},
+	{0x0F12, 0x6024},	//_ee_iLowSharpPower
+	{0x0F12, 0x6024},	//_ee_iLowSharpPower
+	{0xFFFF, 0xFFFF},
+};
+
+LOCAL SENSOR_REG_T s5k4ec_scene_revert_gain[] = {
+	{0xFCFC, 0xD000},
+	{0x0028, 0x7000},
+
+	{0x002A, 0x0638},
+	{0x0F12, 0x0001},
+	{0x0F12, 0x0000}, //lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_0_
+	{0x0F12, 0x0A3C},
+	{0x0F12, 0x0000}, //lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_1_
+	{0x0F12, 0x0D05},
+	{0x0F12, 0x0000}, //lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_2_
+	{0x0F12, 0x3408},
+	{0x0F12, 0x0000}, //lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_3_
+	{0x0F12, 0x3408},
+	{0x0F12, 0x0000}, //lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_4_
+	{0x0F12, 0x6810},
+	{0x0F12, 0x0000}, //lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_5_
+	{0x0F12, 0x8214},
+	{0x0F12, 0x0000}, //lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_6_
+	{0x0F12, 0xC350},
+	{0x0F12, 0x0000}, //lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_7_
+	{0x0F12, 0xC350},
+	{0x0F12, 0x0000}, //lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_8_
+	{0x0F12, 0xC350},
+	{0x0F12, 0x0000}, //lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_9_
+	{0xFFFF, 0xFFFF},
+};
+
+LOCAL SENSOR_REG_T s5k4ec_scene_revert_night[] = {
+	{0xFCFC, 0xD000},
+	{0x0028, 0x7000},
+
+	{0x002A, 0x0A1E},
+	{0x0F12, 0x0350}, //_ccm_oscar_iSaturation
+
+	{0x002A, 0x1648},
+	{0x0F12, 0x9002}, // af_search_usSingleAfFlags
+
+	{0x002A, 0x06B8},
+	{0x0F12, 0x452C},
+	{0x0F12, 0x0005}, //lt_uMaxLei
+
+	{0xFFFF, 0xFFFF},
+};
+
+LOCAL SENSOR_REG_T s5k4ec_scene_revert_sports[] = {
+	{0xFCFC, 0xD000},
+	{0x0028, 0x7000},
+
+	{0x002A, 0x0544},
+	{0x0F12, 0x0111}, //lt_uLimitHigh
+	{0x0F12, 0x00EF}, //lt_uLimitLow
+
+	{0x002A, 0x0938},
+	{0x0F12, 0x0000}, // afit_bUseNB_Afit
+
+	{0xFFFF, 0xFFFF},
+};
+
+//==========================================================
+// Sharpness
+// NOTE: This changes the REG_TC_UserSharpBlur register
+// instead of the AFIT8_ee_iHighSharpPower registers
+// Let the scene mode do that for us.
+//==========================================================
+LOCAL SENSOR_REG_T s5k4ec_sharpness_default[]=
+{
+	{0x0028, 0x7000},
+	{0x002A, 0x0236},
+	{0x0F12, 0x0000},
+	{0xFFFF, 0xFFFF},
+};
+
+LOCAL SENSOR_REG_T s5k4ec_sharpness_plus_1[]=
+{
+	{0x0028, 0x7000},
+	{0x002A, 0x0236},
+	{0x0F12, 0x0080},
+	{0xFFFF, 0xFFFF},
+};
+
+LOCAL SENSOR_REG_T s5k4ec_sharpness_plus_2[] =
+{
+	{0x0028, 0x7000},
+	{0x002A, 0x0236},
+	{0x0F12, 0x0100},
+	{0xFFFF, 0xFFFF},
+};
+
+LOCAL SENSOR_REG_T s5k4ec_sharpness_plus_3[] =
+{
+	{0x0028, 0x7000},
+	{0x002A, 0x0236},
+	{0x0F12, 0x0200},
+	{0xFFFF, 0xFFFF},
+};
+
+LOCAL SENSOR_REG_T s5k4ec_sharpness_minus_1[] = {
+	{0x0028, 0x7000},
+	{0x002A, 0x0236},
+	{0x0F12, 0xFF80},
+	{0xFFFF, 0xFFFF},
+};
+
+LOCAL SENSOR_REG_T s5k4ec_sharpness_minus_2[] = {
+	{0x0028, 0x7000},
+	{0x002A, 0x0236},
+	{0x0F12, 0xFF00},
+	{0xFFFF, 0xFFFF},
+};
+
+LOCAL SENSOR_REG_T s5k4ec_sharpness_minus_3[] = {
+	{0x0028, 0x7000},
+	{0x002A, 0x0236},
+	{0x0F12, 0xFE00},
+	{0xFFFF, 0xFFFF},
+};
 
 //==========================================================
 // SPRD Image params
@@ -4288,57 +4596,21 @@ LOCAL SENSOR_REG_T s5k4ec_image_effect_tab[][15] = {
 	{
 		{0x0028, 0x7000},
 		{0x002A, 0x023C},
-		{0x0F12, 0x0000},
-		{0x002A, 0x04E6},
-		{0x0F12, 0x0777},
-
-		{0x002A, 0x04BA},
-		{0x0F12, 0x0300},
-		{0x0F12, 0x0001},
-		{0x002A, 0x04BE},
-		{0x0F12, 0x0100},
-		{0x0F12, 0x0001},
-		{0x002A, 0x04C2},
-		{0x0F12, 0x0100},
-		{0x0F12, 0x0001},
+		{0x0F12, 0x0006},
 		{0xFFFF, 0xFFFF}
 	},
 	// CAMERA_EFFECT_GREEN         --effect green-tinted
 	{
 		{0x0028, 0x7000},
 		{0x002A, 0x023C},
-		{0x0F12, 0x0000},
-		{0x002A, 0x04E6},
-		{0x0F12, 0x0777},
-
-	  	{0x002A, 0x04BA},
-	  	{0x0F12, 0x0100},
-	  	{0x0F12, 0x0001},
-	  	{0x002A, 0x04BE},
-	  	{0x0F12, 0x0200},
-	  	{0x0F12, 0x0001},
-	  	{0x002A, 0x04C2},
-	  	{0x0F12, 0x0100},
-	  	{0x0F12, 0x0001},
+		{0x0F12, 0x0008},
 		{0xFFFF, 0xFFFF}
 	},
 	// CAMERA_EFFECT_BLUE         --effect blue-tinted
 	{
 		{0x0028, 0x7000},
 		{0x002A, 0x023C},
-		{0x0F12, 0x0000},
-		{0x002A, 0x04E6},
-		{0x0F12, 0x0777},
-
-		{0x002A, 0x04BA},
-		{0x0F12, 0x0100},
-		{0x0F12, 0x0001},
-		{0x002A, 0x04BE},
-		{0x0F12, 0x0100},
-		{0x0F12, 0x0001},
-		{0x002A, 0x04C2},
-		{0x0F12, 0x0200},
-		{0x0F12, 0x0001},
+		{0x0F12, 0x0007},
 		{0xFFFF, 0xFFFF}
 	},
 	// CAMERA_EFFECT_YELLOW       --effect solarize
@@ -4362,26 +4634,47 @@ LOCAL SENSOR_REG_T s5k4ec_image_effect_tab[][15] = {
 		{0x0F12, 0x0004},
 		{0xFFFF, 0xFFFF}
 	},
+	// CAMERA_EFFECT_AQUA    --effect ???
+	{
+		{0x0028, 0x7000},
+		{0x002A, 0x023C},
+		{0x0F12, 0x0005},
+		{0xFFFF, 0xFFFF}
+	},
+	// CAMERA_EFFECT_SKETCH    --effect ???
+	{
+		{0x0028, 0x7000},
+		{0x002A, 0x023C},
+		{0x0F12, 0x0009},
+		{0xFFFF, 0xFFFF}
+	},
+
 };
 
 LOCAL SENSOR_REG_T s5k4ec_anti_banding_flicker_tab[][7] = {
-	{//50hz
+	{//50hz CAMERA_ANTIBANDING_50HZ
 		{0x0028, 0x7000},
-		{0x002a, 0x04e6},
-		{0x0f12, 0x075f},
-		{0x002a, 0x04d6},
-		{0x0f12, 0x0001},
-		{0x0f12, 0x0001},
-		{0xffff, 0xffff}
+		{0x002A, 0x04D6},
+		{0x0F12, 0x0001},
+		{0x0F12, 0x0001},
+		{0xFFFF, 0xFFFF}
+	},
+	{//60hz CAMERA_ANTIBANDING_60HZ
+		{0x0028, 0x7000},
+		{0x002A, 0x04D6},
+		{0x0F12, 0x0002},
+		{0x0F12, 0x0001},
+		{0xFFFF, 0xFFFF}
 	},
-	{//60hz
+	{//OFF CAMERA_ANTIBANDING_OFF
 		{0x0028, 0x7000},
-		{0x002a, 0x04e6},
-		{0x0f12, 0x075f},
-		{0x002a, 0x04d6},
-		{0x0f12, 0x0002},
-		{0x0f12, 0x0001},
-		{0xffff, 0xffff}
+		{0x002A, 0x04D6},
+		{0x0F12, 0x0000},
+		{0x0F12, 0x0001},
+		{0xFFFF, 0xfFFF}
+	},
+	{//AUTO CAMERA_ANTIBANDING_AUTO
+		{0xFFFF, 0xFFFF}
 	}
 };
 
@@ -4482,70 +4775,108 @@ LOCAL SENSOR_REG_T s5k4ec_video_mode_tab[][40] = {
 	}
 };
 
-LOCAL SENSOR_REG_T s5k4ec_awb_tab[][13] = {
+LOCAL SENSOR_REG_T s5k4ec_awb_tab[][11] = {
 	//AUTO
 	{
-		{0x0028, 0x7000},
-		{0x002A ,0x04E6}, {0x0F12 ,0x077F}, {0xffff, 0xffff},
-		{0xffff, 0xffff}, {0xffff, 0xffff}, {0xffff, 0xffff},
-		{0xffff, 0xffff}, {0xffff, 0xffff}, {0xffff, 0xffff},
-		{0xffff, 0xffff}, {0xffff, 0xffff}, {0xffff, 0xffff},
+		{0xffff, 0xffff},
 	},
 	//INCANDESCENCE:
 	{
 		{0x0028, 0x7000},
-		{0x002A ,0x04E6}, {0x0F12 ,0x0777}, {0x002A ,0x04BA},
-		{0x0F12 ,0x066e}, {0x0F12 ,0x0001}, {0x002A ,0x04Be},
-		{0x0F12 ,0x0400}, {0x0F12 ,0x0001}, {0x002A ,0x04c2},
-		{0x0F12 ,0x0476}, {0x0F12 ,0x0001}, {0xffff, 0xffff}
+		{0x002A ,0x04BA},
+		{0x0F12 ,0x066E},
+		{0x0F12 ,0x0001},
+		{0x002A ,0x04BE},
+		{0x0F12 ,0x0400},
+		{0x0F12 ,0x0001},
+		{0x002A ,0x04C2},
+		{0x0F12 ,0x0476},
+		{0x0F12 ,0x0001},
+		{0xFFFF, 0xFFFF},
 	},
 	//CWF equal to flourescent(auto),1
 	{
 		{0x0028, 0x7000},
-		{0x002A ,0x04E6}, {0x0F12 ,0x0777}, {0x002A ,0x04BA},
-		{0x0F12 ,0x0575}, {0x0F12 ,0x0001}, {0x002A ,0x04Be},
-		{0x0F12 ,0x0400}, {0x0F12 ,0x0001}, {0x002A ,0x04c2},
-		{0x0F12 ,0x0800}, {0x0F12 ,0x0001}, {0xffff, 0xffff}
+		{0x002A ,0x04BA},
+		{0x0F12 ,0x0575},
+		{0x0F12 ,0x0001},
+		{0x002A ,0x04BE},
+		{0x0F12 ,0x0400},
+		{0x0F12 ,0x0001},
+		{0x002A ,0x04C2},
+		{0x0F12 ,0x0800},
+		{0x0F12 ,0x0001},
+		{0xFFFF, 0xFFFF}
 	},
 	//U30(auto),2
 	{
 		{0x0028, 0x7000},
-		{0x002A ,0x04E6}, {0x0F12 ,0x0777}, {0x002A ,0x04BA},
-		{0x0F12 ,0x0800}, {0x0F12 ,0x0001}, {0x002A ,0x04Be},
-		{0x0F12 ,0x0400}, {0x0F12 ,0x0001}, {0x002A ,0x04c2},
-		{0x0F12 ,0x0800}, {0x0F12 ,0x0001}, {0xffff, 0xffff}
+		{0x002A ,0x04BA},
+		{0x0F12 ,0x0800},
+		{0x0F12 ,0x0001},
+		{0x002A ,0x04BE},
+		{0x0F12 ,0x0400},
+		{0x0F12 ,0x0001},
+		{0x002A ,0x04C2},
+		{0x0F12 ,0x0800},
+		{0x0F12 ,0x0001},
+		{0xFFFF, 0xFFFF}
 	},
 	//CWF equal to flourescent(auto),3
 	{
 		{0x0028, 0x7000},
-		{0x002A ,0x04E6}, {0x0F12 ,0x0777}, {0x002A ,0x04BA},
-		{0x0F12 ,0x0575}, {0x0F12 ,0x0001}, {0x002A ,0x04Be},
-		{0x0F12 ,0x0400}, {0x0F12 ,0x0001}, {0x002A ,0x04c2},
-		{0x0F12 ,0x0800}, {0x0F12 ,0x0001}, {0xffff, 0xffff}
+		{0x002A ,0x04BA},
+		{0x0F12 ,0x0575},
+		{0x0F12 ,0x0001},
+		{0x002A ,0x04BE},
+		{0x0F12 ,0x0400},
+		{0x0F12 ,0x0001},
+		{0x002A ,0x04C2},
+		{0x0F12 ,0x0800},
+		{0x0F12 ,0x0001},
+		{0xffff, 0xFFFF}
 	},
 	//FLUORESCENT:4
 	{
 		{0x0028, 0x7000},
-		{0x002A ,0x04E6}, {0x0F12 ,0x0777}, {0x002A ,0x04BA},
-		{0x0F12 ,0x0400}, {0x0F12 ,0x0001}, {0x002A ,0x04Be},
-		{0x0F12 ,0x0400}, {0x0F12 ,0x0001}, {0x002A ,0x04c2},
-		{0x0F12 ,0x0940}, {0x0F12 ,0x0001}, {0xffff, 0xffff}
+		{0x002A ,0x04BA},
+		{0x0F12 ,0x0400},
+		{0x0F12 ,0x0001},
+		{0x002A ,0x04BE},
+		{0x0F12 ,0x0400},
+		{0x0F12 ,0x0001},
+		{0x002A ,0x04C2},
+		{0x0F12 ,0x0940},
+		{0x0F12 ,0x0001},
+		{0xFFFF, 0xFFFF}
 	},
 	//SUN:5
 	{
 		{0x0028, 0x7000},
-		{0x002A ,0x04E6}, {0x0F12 ,0x0777}, {0x002A ,0x04BA},
-		{0x0F12 ,0x05e0}, {0x0F12 ,0x0001}, {0x002A ,0x04Be},
-		{0x0F12 ,0x0400}, {0x0F12 ,0x0001}, {0x002A ,0x04c2},
-		{0x0F12 ,0x0530}, {0x0F12 ,0x0001}, {0xffff, 0xffff}
+		{0x002A ,0x04BA},
+		{0x0F12 ,0x05E0},
+		{0x0F12 ,0x0001},
+		{0x002A ,0x04BE},
+		{0x0F12 ,0x0400},
+		{0x0F12 ,0x0001},
+		{0x002A ,0x04C2},
+		{0x0F12 ,0x0530},
+		{0x0F12 ,0x0001},
+		{0xFFFF, 0xFFFF}
 	},
 	//CLOUD:6
 	{
 		{0x0028, 0x7000},
-		{0x002A ,0x04E6}, {0x0F12 ,0x0777}, {0x002A ,0x04BA},
-		{0x0F12 ,0x0740}, {0x0F12 ,0x0001}, {0x002A ,0x04Be},
-		{0x0F12 ,0x0400}, {0x0F12 ,0x0001}, {0x002A ,0x04c2},
-		{0x0F12 ,0x0460}, {0x0F12 ,0x0001}, {0xffff, 0xffff}
+		{0x002A ,0x04BA},
+		{0x0F12 ,0x0740},
+		{0x0F12 ,0x0001},
+		{0x002A ,0x04BE},
+		{0x0F12 ,0x0400},
+		{0x0F12 ,0x0001},
+		{0x002A ,0x04C2},
+		{0x0F12 ,0x0460},
+		{0x0F12 ,0x0001},
+		{0xFFFF, 0xFFFF}
 	}
 };
 
@@ -4556,8 +4887,19 @@ LOCAL SENSOR_REG_T s5k4ec_awb_tab[][13] = {
  * are used to tweak the brightness.
  * I only used 2 sources both are conflicting so I'll use
  * the settings opposite from the stock rom.
+ *
+ * UPDATE: Using the (outdated) datasheet for the s5k4ecgx sensor
+ * Here's what these tables changes:
+ *   TVAR_ae_BrAve (ev from stock rom)
+ *     - Changes the AE's target average brightness
+ *   REG_TC_UserBrightness (ev from sprd opensource)
+ *     - Changes the output brightness
+ *   REG_TC_UserExposureVal88 (ev from the datasheet)
+ *     - Controls the Exposure which _WILL_ affect framerate.
+ *
+ * We'll use the REG_TC_UserExposureVal88 instead
  */
-LOCAL SENSOR_REG_T s5k4ec_brightness_tab[][7] = {
+LOCAL SENSOR_REG_T s5k4ec_ae_brightness_tab[][7] = {
 	{//level -3 TVAR_ae_BrAve
 		{0x0028, 0x7000},{0x002A, 0x1484},{0x0F12, 0x000C}, {0xffff, 0xffff}
 	},
@@ -4582,26 +4924,26 @@ LOCAL SENSOR_REG_T s5k4ec_brightness_tab[][7] = {
 };
 
 LOCAL SENSOR_REG_T s5k4ec_ev_tab[][4] = {
-	{//level -3
-		{0x0028, 0x7000},  {0x002A ,0x0230}, {0x0F12 ,0xFF81}, {0xffff, 0xffff}
+	{//level -3 REG_TC_UserExposureVal88 (2/5 of default)
+		{0x0028, 0x7000}, {0x002A ,0x023A}, {0x0F12 ,0x0067}, {0xffff, 0xffff}
 	},
-	{//level -2
-		{0x0028, 0x7000}, {0x002A ,0x0230}, {0x0F12 ,0xFFAC}, {0xffff, 0xffff}
+	{//level -2 (1/2 of default)
+		{0x0028, 0x7000}, {0x002A ,0x023A}, {0x0F12, 0x0080}, {0xffff, 0xffff}
 	},
-	{//level -1
-		{0x0028, 0x7000},  {0x002A ,0x0230}, {0x0F12 ,0xFFD5}, {0xffff, 0xffff}
+	{//level -1 (2/3 of default)
+		{0x0028, 0x7000}, {0x002A ,0x023A}, {0x0F12 ,0x00C0}, {0xffff, 0xffff}
 	},
 	{//level 0
-		{0x0028, 0x7000},  {0x002A ,0x0230}, {0x0F12 ,0x0000}, {0xffff, 0xffff}
+		{0x0028, 0x7000}, {0x002A ,0x023A}, {0x0F12 ,0x0100}, {0xffff, 0xffff}
 	},
-	{//level 1
-		{0x0028, 0x7000},  {0x002A ,0x0230}, {0x0F12 ,0x002B}, {0xffff, 0xffff}
+	{//level 1 (1.5 times of default)
+		{0x0028, 0x7000}, {0x002A ,0x023A}, {0x0F12 ,0x0180}, {0xffff, 0xffff}
 	},
-	{//level 2
-		{0x0028, 0x7000},  {0x002A ,0x0230}, {0x0F12 ,0x0057}, {0xffff, 0xffff}
+	{//level 2 (2 times of default)
+		{0x0028, 0x7000}, {0x002A ,0x023A}, {0x0F12 ,0x0200}, {0xffff, 0xffff}
 	},
-	{//level 3
-		{0x0028, 0x7000},  {0x002A ,0x0230}, {0x0F12 ,0x007F}, {0xffff, 0xffff}
+	{//level 3 (2.5 times of default)
+		{0x0028, 0x7000}, {0x002A ,0x023A}, {0x0F12 ,0x0280}, {0xffff, 0xffff}
 	}
 };
 
@@ -4610,7 +4952,6 @@ LOCAL SENSOR_REG_T s5k4ec_ev_tab[][4] = {
 //==========================================================
 
 LOCAL SENSOR_REG_T s5k4ec_night_mode_On[] = {
-	{0x0028, 0x7000},
 	{0x0028, 0x7000},
 	{0x002A, 0x0608},
 	{0x0F12, 0x0001}, /*#lt_ExpGain_uSubsamplingmode*/
@@ -4627,14 +4968,17 @@ LOCAL SENSOR_REG_T s5k4ec_low_cap_On[] = {
 	{0x0028, 0x7000},
 
 	{0x002A, 0x06B8},
-	{0x0F12, 0xFFFF},
-	{0x0F12, 0x00FF}, //lt_uMaxLei
+	{0x0F12, 0xFFFF}, //lt_uMaxLei
+	{0x0F12, 0x00FF}, //lt_usMinExp
+
 	{0x002A, 0x0A1A},
 	{0x0F12, 0x4A18}, //Gamma linearity
+
 	{0x002A, 0x0608},
 	{0x0F12, 0x0001}, //lt_ExpGain_uSubsamplingmode
 	{0x0F12, 0x0001}, //lt_ExpGain_uNonSubsampling
 	{0x0F12, 0x0850}, //lt_ExpGain_ExpCurveGainMaxStr
+
 	{0x002A, 0x0938},
 	{0x0F12, 0x0001},
 	{0x0F12, 0x0012}, //SARR_uNormBrInDoor_0_
@@ -4642,15 +4986,48 @@ LOCAL SENSOR_REG_T s5k4ec_low_cap_On[] = {
 	{0x0F12, 0x0384}, //SARR_uNormBrInDoor_2_
 	{0x0F12, 0x07D0}, //SARR_uNormBrInDoor_3_
 	{0x0F12, 0x1388}, //SARR_uNormBrInDoor_4_
+
+	{0x002A, 0x0638},
+	{0x0F12, 0x0001},
+	{0x0F12, 0x0000},/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_0_ */
+	{0x0F12, 0x0A3C},
+	{0x0F12, 0x0000},/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_1_ */
+	{0x0F12, 0x0D05},
+	{0x0F12, 0x0000},/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_2_ */
+	{0x0F12, 0x3408},
+	{0x0F12, 0x0000},/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_3_ */
+	{0x0F12, 0x3408},
+	{0x0F12, 0x0000},/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_4_ */
+	{0x0F12, 0xD020},
+	{0x0F12, 0x0000},/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_5_ */
+	{0x0F12, 0x0428},
+	{0x0F12, 0x0001},/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_6_ */
+	{0x0F12, 0x1A80},
+	{0x0F12, 0x0006},/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_7_ */
+	{0x0F12, 0x1A80},
+	{0x0F12, 0x0006},/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_8_ */
+	{0x0F12, 0x1A80},
+	{0x0F12, 0x0006},/*lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_9_ */
+
+	{0x002A, 0x0266},
+	{0x0F12, 0x0000}, /*REG_TC_GP_ActivePrevConfig */
+	{0x002A, 0x024E},
+	{0x0F12, 0x0001}, /*REG_TC_GP_NewConfigSync */
+	{0x002A, 0x0270},
+	{0x0F12, 0x0001}, /*REG_TC_GP_CapConfigChanged */
+
 	{0xFFFF, 0xFFFF},
 };
 
 LOCAL SENSOR_REG_T s5k4ec_low_cap_Off[] = {
+	{0x0028, 0x7000},
 	{0x002A, 0x06B8},
 	{0x0F12, 0x452C},
 	{0x0F12, 0x0005}, //lt_uMaxLei
+
 	{0x002A, 0x0A1A},
 	{0x0F12, 0x8F18}, //Gamma linearity
+
 	{0x002A, 0x0608},
 	{0x0F12, 0x0001}, //lt_ExpGain_uSubsamplingmode
 	{0x0F12, 0x0001}, //lt_ExpGain_uNonSubsampling
@@ -4662,6 +5039,30 @@ LOCAL SENSOR_REG_T s5k4ec_low_cap_Off[] = {
 	{0x0F12, 0x0384}, //#SARR_uNormBrInDoor_2_
 	{0x0F12, 0x07D0}, //#SARR_uNormBrInDoor_3_
 	{0x0F12, 0x1388}, //#SARR_uNormBrInDoor_4_
+
+	//Exposure
+	{0x002A, 0x0638},		//0638
+	{0x0F12, 0x0001},		//0001
+	{0x0F12, 0x0000},		//0000 lt_ExpGain_ExpCurveGainMaxStr_0__ulExpOut_0_
+	{0x0F12, 0x0A3C},		//0A3C
+	{0x0F12, 0x0000},		//0000
+	{0x0F12, 0x0D05},		//0D05
+	{0x0F12, 0x0000},		//0000
+	{0x0F12, 0x3408},		//3408
+	{0x0F12, 0x0000},		//0000
+	{0x0F12, 0x3408},		//3408
+	{0x0F12, 0x0000},		//0000
+	{0x0F12, 0x6810},		//6810
+	{0x0F12, 0x0000},		//0000
+	{0x0F12, 0x8214},		//8214
+	{0x0F12, 0x0000},		//0000
+	{0x0F12, 0xC350},		//C350
+	{0x0F12, 0x0000},		//0000
+	{0x0F12, 0xC350},		//C350
+	{0x0F12, 0x0000},		//0000
+	{0x0F12, 0xC350},		//C350
+	{0x0F12, 0x0000},		//0000
+
 	{0xFFFF, 0xFFFF},
 };
 
@@ -4718,27 +5119,110 @@ LOCAL SENSOR_REG_T s5k4ec_AF_normal_mode_3[] = {
 };
 
 LOCAL SENSOR_REG_T s5k4ec_AF_macro_mode_1[] = {
+	{0xFCFC, 0xD000},
 	{0x0028, 0x7000},
-	{0x002A, 0x0288},
+	{0x002A, 0x028E},
 	{0x0F12, 0x00D0},
 	{0xFFFF, 0xFFFF},
 };
 
 LOCAL SENSOR_REG_T s5k4ec_AF_macro_mode_2[] = {
-	{0x002A, 0x0286},
+	{0xFCFC, 0xD000},
+	{0x0028, 0x7000},
+	{0x002A, 0x028C},
 	{0x0F12, 0x0004},
 	{0xFFFF, 0xFFFF},
 };
 
 LOCAL SENSOR_REG_T s5k4ec_AF_macro_mode_3[] = {
-	{0x002A, 0x160C},
-	{0x0F12, 0x1042},
-	{0x002A, 0x159E},
+	{0xFCFC, 0xD000},
+	{0x0028, 0x7000},
+
+	{0x002A, 0x1648},
+	{0x0F12, 0x9042},
+
+	{0x002A, 0x15E8},
+	{0x0F12, 0x0017},   //af_pos_usTableLastInd, 24 stops
+	{0x0F12, 0x0032},
+	{0x0F12, 0x0038},
+	{0x0F12, 0x003E},
+	{0x0F12, 0x0044},
+	{0x0F12, 0x004A},
+	{0x0F12, 0x0050},
+	{0x0F12, 0x0056},
+	{0x0F12, 0x005C},
+	{0x0F12, 0x0062},
+	{0x0F12, 0x0068},
+	{0x0F12, 0x006E},
+	{0x0F12, 0x0074},
+	{0x0F12, 0x007A},
+	{0x0F12, 0x0080},
+	{0x0F12, 0x0086},
+	{0x0F12, 0x008C},
+	{0x0F12, 0x0092},
+	{0x0F12, 0x0098},
+	{0x0F12, 0x009E},
+	{0x0F12, 0x00A4},
+	{0x0F12, 0x00AA},
+	{0x0F12, 0x00B0},
+	{0x0F12, 0x00C0},
+	{0x0F12, 0x00D0},
+
+	{0x002A, 0x15DA}, 	// 16 start number of table 00 End number of table
 	{0x0F12, 0x1700},
 	{0xFFFF, 0xFFFF},
 
 };
 
+LOCAL SENSOR_REG_T s5k4ec_AF_continuous_mode_1[] = {
+	{0xFCFC, 0xD000},
+	{0x0028, 0x7000},
+
+	{0x002A, 0x163E},
+	{0x0F12, 0x00E6},   //af_search_usPeakThr
+	{0x0F12, 0x00C2},   //af_search_usPeakThrLow
+
+	{0x002A, 0x028E},
+	{0x0F12, 0x0000},   //REG_TC_AF_AfCmdParam
+
+	{0xFFFF, 0xFFFF},
+};
+
+LOCAL SENSOR_REG_T s5k4ec_AF_continuous_mode_2[] = {
+	{0xFCFC, 0xD000},
+	{0x0028, 0x7000},
+
+	{0x002A, 0x15E8},
+	{0x0F12, 0x0018}, //#af_pos_usTableLastInd// table0 ~ table24,  25 Steps
+	{0x0F12, 0x0018}, //#af_pos_usTable_0_ // af_pos_usTable
+	{0x0F12, 0x0030}, //#af_pos_usTable_1_
+	{0x0F12, 0x0048}, //#af_pos_usTable_2_
+	{0x0F12, 0x0058}, //#af_pos_usTable_3_
+	{0x0F12, 0x0068}, //#af_pos_usTable_4_
+	{0x0F12, 0x0070}, //#af_pos_usTable_5_
+	{0x0F12, 0x0078}, //#af_pos_usTable_6_
+	{0x0F12, 0x0080}, //#af_pos_usTable_7_
+	{0x0F12, 0x0088}, //#af_pos_usTable_8_
+	{0x0F12, 0x0090}, //#af_pos_usTable_9_
+	{0x0F12, 0x0098}, //#af_pos_usTable_10_
+	{0x0F12, 0x0090}, //#af_pos_usTable_11_
+	{0x0F12, 0x0098}, //#af_pos_usTable_12_
+	{0x0F12, 0x0054}, //#af_pos_usTable_13_
+	{0x0F12, 0x0058}, //#af_pos_usTable_14_
+	{0x0F12, 0x005C}, //#af_pos_usTable_15_
+	{0x0F12, 0x0060}, //#af_pos_usTable_16_
+	{0x0F12, 0x0064}, //#af_pos_usTable_17_
+	{0x0F12, 0x0068}, //#af_pos_usTable_18_
+	{0x0F12, 0x006C}, //#af_pos_usTable_19_
+	{0x0F12, 0x0070}, //#af_pos_usTable_20_
+	{0x0F12, 0x0074}, //#af_pos_usTable_21_
+	{0x0F12, 0x0078}, //#af_pos_usTable_22_
+	{0x0F12, 0x007C}, //#af_pos_usTable_23_
+	{0x0F12, 0x0080}, //#af_pos_usTable_24_
+
+	{0xFFFF, 0xFFFF},
+};
+
 LOCAL SENSOR_REG_T s5k4ec_single_AF_start[] = {
 	{0xFCFC, 0xD000},
 	{0x0028, 0x7000},
@@ -4747,6 +5231,14 @@ LOCAL SENSOR_REG_T s5k4ec_single_AF_start[] = {
 	{0xFFFF, 0xFFFF},
 };
 
+LOCAL SENSOR_REG_T s5k4ec_continuous_AF_start[] = {
+	{0xFCFC, 0xD000},
+	{0x0028, 0x7000},
+	{0x002A, 0x028C},
+	{0x0F12, 0x0006},
+	{0xFFFF, 0xFFFF},
+};
+
 LOCAL SENSOR_REG_T s5k4ec_AF_off_1[] = {
 	{0xFCFC, 0xD000},
 	{0x0028, 0x7000},
@@ -4757,16 +5249,29 @@ LOCAL SENSOR_REG_T s5k4ec_AF_off_1[] = {
 	{0xFFFF, 0xFFFF},
 };
 
-LOCAL SENSOR_REG_T s5k4ec_AF_return_inf_pos[] = {
-	{0x002A, 0x15D6},
-	{0x0F12, 0xD000},
+LOCAL SENSOR_REG_T s5k4ec_AF_revert_continuous_mode[] = {
+	{0xFCFC, 0xD000},
+	{0x0028, 0x7000},
+	{0x002A, 0x163E},
+	{0x0F12, 0x00C2},   //af_search_usPeakThr
+	{0x0F12, 0x0098},   //af_search_usPeakThrLow
 	{0xFFFF, 0xFFFF},
 };
 
-LOCAL SENSOR_REG_T s5k4ec_AF_low_light_mode_On[] = {
+LOCAL SENSOR_REG_T s5k4ec_AF_low_light_macro_mode[] = {
+	{0xFCFC, 0xD000},
+	{0x0028, 0x7000},
+
 	{0x002A, 0x15DA},
 	{0x0F12, 0x0C00},
 
+	{0xFFFF, 0xFFFF},
+};
+
+LOCAL SENSOR_REG_T s5k4ec_AF_low_light_mode_On[] = {
+	{0xFCFC, 0xD000},
+	{0x0028, 0x7000},
+
 	{0x002A, 0x15E8},
 	{0x0F12, 0x000C},
 	{0x0F12, 0x002A},
@@ -4782,10 +5287,14 @@ LOCAL SENSOR_REG_T s5k4ec_AF_low_light_mode_On[] = {
 	{0x0F12, 0x0093},
 	{0x0F12, 0x00A2},
 	{0x0F12, 0x00B1},
+
 	{0xFFFF, 0xFFFF},
 };
 
 LOCAL SENSOR_REG_T s5k4ec_AF_low_light_mode_Off[] = {
+	{0xFCFC, 0xD000},
+	{0x0028, 0x7000},
+
 	{0x002A, 0x15DA},
 	{0x0F12, 0x1800},
 
@@ -4829,9 +5338,9 @@ LOCAL SENSOR_REG_T s5k4ec_Auto30_FPS[] = { //10-30 fps
 
 	{0x002A, 0x02BE},
 	{0x0F12, 0x0000},
-	{0x0F12, 0x0001},
+	{0x0F12, 0x0000},
 	{0x0F12, 0x03E8}, //29A = 66.7msec(15fps) //03E8 = 100msec (10fps) // 7D0 = 200msec (5fps)
-	{0x0F12, 0x014A},
+	{0x0F12, 0x0000},
 
 	{0x002A, 0x0266},
 	{0x0F12, 0x0000},
@@ -4945,6 +5454,38 @@ LOCAL SENSOR_REG_T s5k4ec_15_FPS[] = {
 	{0xFFFF, 0xFFFF},
 };
 
+LOCAL SENSOR_REG_T s5k4ec_24_FPS[] = {
+	{0xFCFC, 0xD000},
+	{0x0028, 0xD000},
+
+	{0x002A, 0xF132},
+	{0x0F12, 0x0200},
+
+	{0x002A, 0xF142},
+	{0x0F12, 0x0200},
+
+	{0x0028, 0x7000},
+
+	{0x002A, 0x02B4},
+	{0x0F12, 0x0012},
+
+	{0x002A, 0x02BE},
+	{0x0F12, 0x0000},
+	{0x0F12, 0x0001},
+	{0x0F12, 0x01A0},
+	{0x0F12, 0x01A0},
+
+	{0x002A, 0x0266},
+	{0x0F12, 0x0000},
+	{0x002A, 0x026A},
+	{0x0F12, 0x0001},
+	{0x002A, 0x024E},
+	{0x0F12, 0x0001},
+	{0x002A, 0x0268},
+	{0x0F12, 0x0001},
+	{0xFFFF, 0xFFFF},
+};
+
 LOCAL SENSOR_REG_T s5k4ec_25_FPS[] = {
 	{0xFCFC, 0xD000},
 	{0x0028, 0xD000},
@@ -4989,9 +5530,6 @@ LOCAL SENSOR_REG_T s5k4ec_30_FPS[] = {
 
 	{0x0028, 0x7000},
 
-	{0x002A, 0x02B4},
-	{0x0F12, 0x0052},
-
 	{0x002A, 0x02BE},
 	{0x0F12, 0x0000},
 	{0x0F12, 0x0001},
@@ -5008,16 +5546,64 @@ LOCAL SENSOR_REG_T s5k4ec_30_FPS[] = {
 	{0x0F12, 0x1388},
 
 	{0x002A, 0x0266},
-	{0x0F12, 0x0000},
+	{0x0F12, 0x0000}, //REG_TC_GP_ActivePrevConfig
 	{0x002A, 0x026A},
-	{0x0F12, 0x0001},
+	{0x0F12, 0x0001}, //REG_TC_GP_PrevOpenAfterChange
 	{0x002A, 0x024E},
-	{0x0F12, 0x0001},
+	{0x0F12, 0x0001}, //REG_TC_GP_NewConfigSync
 	{0x002A, 0x0268},
-	{0x0F12, 0x0001},
+	{0x0F12, 0x0001}, //REG_TC_GP_PrevConfigChanged
+	{0xFFFF, 0xFFFF},
+};
+
+//==========================================================
+// Capture FPS modes
+// NOTE: This indirectly affects the slowest possible
+// shutter speed used on photos.
+// CAUTION: These regs have to be set to 1 when using this
+//    REG_TC_GP_NewConfigSync and REG_TC_GP_CapConfigChanged
+//    Yet, these reg settings don't. Since most often, the
+//    succeeding reg settings will eventually call it.
+//==========================================================
+
+// "short exposure" mode. Stock settings. Up to 133 milliseconds
+// Used for normal photography with/without flash.
+LOCAL SENSOR_REG_T s5k4ec_capture_short_FPS[] = {
+	{0x0028, 0x7000},
+	{0x002A, 0x03B0},
+	{0x0F12, 0x0000}, // REG_0TC_CCFG_usFrTimeType
+	{0x0F12, 0x0000}, // REG_0TC_CCFG_FrRateQualityType
+	{0x0F12, 0x0535}, // REG_0TC_CCFG_usMaxFrTimeMsecMult10
+	{0x0F12, 0x029A}, // REG_0TC_CCFG_usMinFrTimeMsecMult10
 	{0xFFFF, 0xFFFF},
 };
 
+// "Medium exposure" mode. Up to 325 milliseconds
+// Used in non-flash low light capture
+LOCAL SENSOR_REG_T s5k4ec_capture_med_FPS[] = {
+	{0x0028, 0x7000},
+	{0x002A, 0x03B0},
+	{0x0F12, 0x0000}, // REG_0TC_CCFG_usFrTimeType
+	{0x0F12, 0x0002}, // REG_0TC_CCFG_FrRateQualityType
+	{0x0F12, 0x0CB2}, // REG_0TC_CCFG_usMaxFrTimeMsecMult10
+	{0x0F12, 0x0000}, // REG_0TC_CCFG_usMinFrTimeMsecMult10
+	{0xFFFF, 0xFFFF},
+};
+
+// "Long exposure" mode. Up to 650 milliseconds
+// Built in the night scene mode reg setting.
+// Basically, this is just for display.
+LOCAL SENSOR_REG_T s5k4ec_capture_long_FPS[] = {
+	{0x0028, 0x7000},
+	{0x002A, 0x03B0},
+	{0x0F12, 0x0000}, // REG_0TC_CCFG_usFrTimeType
+	{0x0F12, 0x0002}, // REG_0TC_CCFG_FrRateQualityType
+	{0x0F12, 0x1964}, // REG_0TC_CCFG_usMaxFrTimeMsecMult10
+	{0x0F12, 0x0000}, // REG_0TC_CCFG_usMinFrTimeMsecMult10
+	{0xFFFF, 0xFFFF},
+};
+
+
 //==========================================================
 // Metering modes
 //==========================================================
@@ -5154,6 +5740,7 @@ LOCAL SENSOR_REG_T s5k4ec_metering_center_weighted[] = {
 //==========================================================
 // State Triggers
 //==========================================================
+// Disables capture state (which when enabled, disables both AWB and AE)
 LOCAL SENSOR_REG_T s5k4ec_preview_return[] = {
 	{0xFCFC, 0xD000},
 	{0x0028, 0x7000},
@@ -5166,11 +5753,14 @@ LOCAL SENSOR_REG_T s5k4ec_preview_return[] = {
 	{0xFFFF, 0xFFFF},
 };
 
+// Invokes a Capture request
 LOCAL SENSOR_REG_T s5k4ec_capture_start[] = {
 	{0xFCFC, 0xD000},
+
 	{0x0028, 0x7000},
 	{0x002A, 0x0242},
 	{0x0F12, 0x0001},	//REG_TC_GP_EnableCapture
+
 	{0x002A, 0x024E},
 	{0x0F12, 0x0001},	//REG_TC_GP_NewConfigSync
 	{0x002A, 0x0244},
@@ -5178,10 +5768,42 @@ LOCAL SENSOR_REG_T s5k4ec_capture_start[] = {
 	{0xFFFF, 0xFFFF},
 };
 
+// Disables both Capture and Preview modes/streams
+LOCAL SENSOR_REG_T s5k4ec_Stream_Off[] = {
+	{0x0028, 0x7000},
+	{0x002A, 0x023E},
+	{0x0F12, 0x0000},	//#REG_TC_GP_EnablePreview
+	{0x002A, 0x0242},
+	{0x0F12, 0x0000},	//REG_TC_GP_EnableCapture
+
+	{0x0028, 0xD000},
+	{0x002A, 0xB0A0},
+	{0x0F12, 0x0000},	//Clear cont. clock befor config change
+
+	{0x0028, 0x7000},
+	{0x002A, 0x0240},
+	{0x0F12, 0x0001},	//#REG_TC_GP_EnablePreviewChanged
+	{0x002A, 0x0244},
+	{0x0F12, 0x0001},	//REG_TC_GP_EnableCaptureChanged
+	{0xFFFF, 0xFFFF},
+};
+
+// Enables preview stream
+LOCAL SENSOR_REG_T s5k4ec_preview_Stream_On[] = {
+	{0x0028, 0x7000},
+	{0x002A, 0x023E},
+	{0x0F12, 0x0001},  //#REG_TC_GP_EnablePreview
+	{0x0F12, 0x0001},  //#REG_TC_GP_EnablePreviewChanged
+
+	{0x0028, 0xD000},
+	{0x002A, 0x1000},
+	{0x0F12, 0x0001},
+	{0xFFFF, 0xFFFF},
+};
 
 //==========================================================
 // Preview and Capture Sizes
-// WARNING: Leave out the {0xFFFF, 0xFFFF} at the end
+// CAUTION: Leave out the {0xFFFF, 0xFFFF} at the end
 // 0xFFFF means to sleep for 0xFFFF (65535) milliseconds
 //==========================================================
 // 320X240 YUV (Preview and Capture)
@@ -5192,8 +5814,8 @@ LOCAL SENSOR_REG_T s5k4ec_320X240[] = {
 	{0x002A, 0x18AC},
 	{0x0F12, 0x0060},	//senHal_uAddColsBin
 	{0x0F12, 0x0060},	//senHal_uAddColsNoBin
-	{0x0F12, 0x05C0},	//senHal_uMinColsBin
-	{0x0F12, 0x05C0},	//senHal_uMinColsNoBin
+	{0x0F12, 0x06C8},	//senHal_uMinColsBin
+	{0x0F12, 0x06C8},	//senHal_uMinColsNoBin
 
 	{0x002A, 0x0250},
 	{0x0F12, 0x0A00},	//REG_TC_GP_PrevReqInputWidth //2560
@@ -5232,8 +5854,8 @@ LOCAL SENSOR_REG_T s5k4ec_640X480[] = {
 	{0x002A, 0x18AC},
 	{0x0F12, 0x0060},	//senHal_uAddColsBin
 	{0x0F12, 0x0060},	//senHal_uAddColsNoBin
-	{0x0F12, 0x05C0},	//senHal_uMinColsBin
-	{0x0F12, 0x05C0},	//senHal_uMinColsNoBin
+	{0x0F12, 0x06C8},	//senHal_uMinColsBin
+	{0x0F12, 0x06C8},	//senHal_uMinColsNoBin
 
 	{0x002A, 0x0250},
 	{0x0F12, 0x0A00},	//REG_TC_GP_PrevReqInputWidth //2560
@@ -5273,8 +5895,8 @@ LOCAL SENSOR_REG_T s5k4ec_720X540[] ={
 	{0x002A, 0x18AC},
 	{0x0F12, 0x0060},	//senHal_uAddColsBin
 	{0x0F12, 0x0060},	//senHal_uAddColsNoBin
-	{0x0F12, 0x05C0},	//senHal_uMinColsBin
-	{0x0F12, 0x05C0},	//senHal_uMinColsNoBin
+	{0x0F12, 0x06C8},	//senHal_uMinColsBin
+	{0x0F12, 0x06C8},	//senHal_uMinColsNoBin
 
 	{0x002A, 0x0250},
 	{0x0F12, 0x0A00},	//REG_TC_GP_PrevReqInputWidth //2560
@@ -5314,8 +5936,8 @@ LOCAL SENSOR_REG_T s5k4ec_800X480[] = {
 	{0x002A, 0x18AC},
 	{0x0F12, 0x0060},	//senHal_uAddColsBin
 	{0x0F12, 0x0060},	//senHal_uAddColsNoBin
-	{0x0F12, 0x05C0},	//senHal_uMinColsBin
-	{0x0F12, 0x05C0},	//senHal_uMinColsNoBin
+	{0x0F12, 0x06C8},	//senHal_uMinColsBin
+	{0x0F12, 0x06C8},	//senHal_uMinColsNoBin
 
 	{0x002A, 0x0250},
 	{0x0F12, 0x0A00},	//REG_TC_GP_PrevReqInputWidth //2560
@@ -5365,9 +5987,10 @@ LOCAL SENSOR_REG_T s5k4ec_800X480[] = {
 	{0x0F12, 0x0001},	//REG_TC_GP_CapConfigChanged
 };
 
-//1280X720 YUV (Preview and Capture)
-LOCAL SENSOR_REG_T s5k4ec_1280X720[] = {
+//1024X768 YUV (Preview and Capture)
+LOCAL SENSOR_REG_T s5k4ec_1024X768[] = {
 	{0x0028, 0x7000},
+
 	{0x002A, 0x18AC},
 	{0x0F12, 0x0060},	//	#senHal_uAddColsBin 	//
 	{0x0F12, 0x0060},	//	#senHal_uAddColsNoBin	//
@@ -5375,25 +5998,26 @@ LOCAL SENSOR_REG_T s5k4ec_1280X720[] = {
 	{0x0F12, 0x05C0},	//	#senHal_uMinColsNoBin	//
 
 	{0x002A, 0x02A6},
-	{0x0F12, 0x0500},	//	#REG_0TC_PCFG_usWidth  //Hsize	 : 800			//
-	{0x0F12, 0x02D0}, //	#REG_0TC_PCFG_usHeight//Vsize	: 480		//
+	{0x0F12, 0x0400},	//	#REG_0TC_PCFG_usWidth  //Hsize	: 1024		//
+	{0x0F12, 0x0300},	//	#REG_0TC_PCFG_usHeight //Vsize	: 768		//
 
 	{0x002A, 0x0250},
-	{0x0F12, 0x0A00},	//#REG_TC_GP_PrevReqInputWidth						//Sensor Crop Width 2560
-	{0x0F12, 0x05A0},	//#REG_TC_GP_PrevReqInputHeight 					//Sensor Crop Height	1536
-	{0x0F12, 0x0010},	//#REG_TC_GP_PrevInputWidthOfs						//Sensor HOffset	16 = (2592-2560)/2
-	{0x0F12, 0x00F0},	//#REG_TC_GP_PrevInputHeightOfs 					//Sensor VOffset	204 = (1944-1536)/2
-	{0x0F12, 0x0A00},	//#REG_TC_GP_CapReqInputWidth							//Sensor Crop Width 2560
-	{0x0F12, 0x05A0},	//#REG_TC_GP_CapReqInputHeight						//Sensor Crop Height	1536
-	{0x0F12, 0x0010},	//#REG_TC_GP_CapInputWidthOfs							//Sensor HOffset	16 = (2592-2560)/2
-	{0x0F12, 0x00F0},	//#REG_TC_GP_CapInputHeightOfs						//Sensor VOffset	204 = (1944-1536)/2
+	{0x0F12, 0x0A00},	//#REG_TC_GP_PrevReqInputWidth	//Sensor Crop Width  2560
+	{0x0F12, 0x0780},	//#REG_TC_GP_PrevReqInputHeight //Sensor Crop Height 1920
+	{0x0F12, 0x0010},	//#REG_TC_GP_PrevInputWidthOfs	//Sensor HOffset	16 = (2592-2560)/2
+	{0x0F12, 0x000C},	//#REG_TC_GP_PrevInputHeightOfs //Sensor VOffset	12 = (1944-1920)/2
+	{0x0F12, 0x0A00},	//#REG_TC_GP_CapReqInputWidth	//Sensor Crop Width  2560
+	{0x0F12, 0x0780},	//#REG_TC_GP_CapReqInputHeight	//Sensor Crop Height 1920
+	{0x0F12, 0x0010},	//#REG_TC_GP_CapInputWidthOfs	//Sensor HOffset	16 = (2592-2560)/2
+	{0x0F12, 0x000C},	//#REG_TC_GP_CapInputHeightOfs	//Sensor VOffset	12 = (1944-1920)/2
+
 	{0x002A, 0x0494},
-	{0x0F12, 0x0A00},	//#REG_TC_PZOOM_PrevZoomReqInputWidth			//ISP	Input Width 2560
-	{0x0F12, 0x05A0},	//#REG_TC_PZOOM_PrevZoomReqInputHeight		//ISP	Input Height	1536
+	{0x0F12, 0x0A00},	//#REG_TC_PZOOM_PrevZoomReqInputWidth		//ISP	Input Width 2560
+	{0x0F12, 0x0780},	//#REG_TC_PZOOM_PrevZoomReqInputHeight		//ISP	Input Height	1920
 	{0x0F12, 0x0000},	//#REG_TC_PZOOM_PrevZoomReqInputWidthOfs	//ISP	Input HOffset	0
 	{0x0F12, 0x0000},	//#REG_TC_PZOOM_PrevZoomReqInputHeightOfs	//ISP	Input VOffset	0
-	{0x0F12, 0x0A00},	//#REG_TC_PZOOM_CapZoomReqInputWidth			//ISP	Input Width 2560
-	{0x0F12, 0x05A0},	//#REG_TC_PZOOM_CapZoomReqInputHeight			//ISP	Input Height	1536
+	{0x0F12, 0x0A00},	//#REG_TC_PZOOM_CapZoomReqInputWidth		//ISP	Input Width 2560
+	{0x0F12, 0x0780},	//#REG_TC_PZOOM_CapZoomReqInputHeight		//ISP	Input Height	1920
 	{0x0F12, 0x0000},	//#REG_TC_PZOOM_CapZoomReqInputWidthOfs 	//ISP	Input HOffset	0
 	{0x0F12, 0x0000},	//#REG_TC_PZOOM_CapZoomReqInputHeightOfs	//ISP	Input VOffset	0
 
@@ -5412,9 +6036,6 @@ LOCAL SENSOR_REG_T s5k4ec_1280X720[] = {
 	{0x0F12, 0x0001},	//	#REG_TC_GP_PrevConfigChanged	//
 	{0x002A, 0x0270},
 	{0x0F12, 0x0001},	//	#REG_TC_GP_CapConfigChanged 	//
-	{0x002A, 0x023E},
-	{0x0F12, 0x0001},	//	#REG_TC_GP_EnablePreview		//
-	{0x0F12, 0x0001},	//	#REG_TC_GP_EnablePreviewChanged //
 };
 
 // 1280X960 YUV Preview/Capture Mode
@@ -5449,12 +6070,12 @@ LOCAL SENSOR_REG_T s5k4ec_1280X960[] = {
 
 	{0x002A, 0x0494},
 	{0x0F12, 0x0A00},	//REG_TC_PZOOM_PrevZoomReqInputWidth //ISP  Input Width 2560
-	{0x0F12, 0x0780},	//REG_TC_PZOOM_PrevZoomReqInputHeight //ISP  Input Height 1920
+	{0x0F12, 0x0780},	//REG_TC_PZOOM_PrevZoomReqInputHeight //ISP  Input Height 1960
 	{0x0F12, 0x0000},	//REG_TC_PZOOM_PrevZoomReqInputWidthOfs //ISP  Input HOffset 0
 	{0x0F12, 0x0000},	//REG_TC_PZOOM_PrevZoomReqInputHeightOfs //ISP  Input VOffset 0
 
 	{0x0F12, 0x0A00},	//REG_TC_PZOOM_CapZoomReqInputWidth ISP  Input Width 2560
-	{0x0F12, 0x0600},	//REG_TC_PZOOM_CapZoomReqInputHeight //ISP  Input Height 1920
+	{0x0F12, 0x0780},	//REG_TC_PZOOM_CapZoomReqInputHeight //ISP  Input Height 1920
 	{0x0F12, 0x0000},	//REG_TC_PZOOM_CapZoomReqInputWidthOfs //ISP  Input HOffset 0
 	{0x0F12, 0x0000},	//REG_TC_PZOOM_CapZoomReqInputHeightOfs //ISP  Input VOffset 0
 
@@ -5472,9 +6093,6 @@ LOCAL SENSOR_REG_T s5k4ec_1280X960[] = {
 	{0x0F12, 0x0001},	//	#REG_TC_GP_PrevConfigChanged	//
 	{0x002A, 0x0270},
 	{0x0F12, 0x0001},	//	#REG_TC_GP_CapConfigChanged 	//
-	{0x002A, 0x023E},
-	{0x0F12, 0x0001},	//	#REG_TC_GP_EnablePreview		//
-	{0x0F12, 0x0001},	//	#REG_TC_GP_EnablePreviewChanged //
 };
 
 //1600X1200  YUV Mode (Capture Only)
@@ -5486,8 +6104,8 @@ LOCAL SENSOR_REG_T s5k4ec_1600X1200[] = {
 	{0x002A, 0x18AC},
 	{0x0F12, 0x0060},	//senHal_uAddColsBin
 	{0x0F12, 0x0060},	//senHal_uAddColsNoBin
-	{0x0F12, 0x05C0},	//senHal_uMinColsBin
-	{0x0F12, 0x05C0},	//senHal_uMinColsNoBin
+	{0x0F12, 0x06C8},	//senHal_uMinColsBin
+	{0x0F12, 0x06C8},	//senHal_uMinColsNoBin
 
 	{0x002A, 0x0258},
 	{0x0F12, 0x0A00}, 	  /*REG_TC_GP_CapReqInputWidth 2560 */
@@ -5527,8 +6145,8 @@ LOCAL SENSOR_REG_T s5k4ec_2048X1536[] = {
 	{0x002A, 0x18AC},
 	{0x0F12, 0x0060},	//senHal_uAddColsBin
 	{0x0F12, 0x0060},	//senHal_uAddColsNoBin
-	{0x0F12, 0x05C0},	//senHal_uMinColsBin
-	{0x0F12, 0x05C0},	//senHal_uMinColsNoBin
+	{0x0F12, 0x06C8},	//senHal_uMinColsBin
+	{0x0F12, 0x06C8},	//senHal_uMinColsNoBin
 
 	{0x002A, 0x0258},
 	{0x0F12, 0x0A00}, 	  /*REG_TC_GP_CapReqInputWidth 2560 */
@@ -5568,37 +6186,37 @@ LOCAL SENSOR_REG_T s5k4ec_2560X1920[] = {
 	{0x002A, 0x18AC},
 	{0x0F12, 0x0060},	//senHal_uAddColsBin
 	{0x0F12, 0x0060},	//senHal_uAddColsNoBin
-	{0x0F12, 0x05C0},	//senHal_uMinColsBin
-	{0x0F12, 0x05C0},	//senHal_uMinColsNoBin
+	{0x0F12, 0x06C8},	//senHal_uMinColsBin
+	{0x0F12, 0x06C8},	//senHal_uMinColsNoBin
 
 	{0x002A, 0x0258},
-	{0x0F12, 0x0A00},		/*REG_TC_GP_CapReqInputWidth 2560 */
-	{0x0F12, 0x0780},		/*REG_TC_GP_CapReqInputHeight 1920 */
-	{0x0F12, 0x0010},		/*REG_TC_GP_CapInputWidthOfs (2592-2560)/2 */
-	{0x0F12, 0x000C},		/*REG_TC_GP_CapInputHeightOfs (1944-1920)/2 */
+	{0x0F12, 0x0A00},	/*REG_TC_GP_CapReqInputWidth 2560 */
+	{0x0F12, 0x0780},	/*REG_TC_GP_CapReqInputHeight 1920 */
+	{0x0F12, 0x0010},	/*REG_TC_GP_CapInputWidthOfs (2592-2560)/2 */
+	{0x0F12, 0x000C},	/*REG_TC_GP_CapInputHeightOfs (1944-1920)/2 */
 
 	{0x002A, 0x0264},
-	{0x0F12, 0x0001},		/*REG_TC_GP_bUseReqInputInCap */
+	{0x0F12, 0x0001},	/*REG_TC_GP_bUseReqInputInCap */
 
 	{0x002A, 0x049C},
-	{0x0F12, 0x0A00},		/*REG_TC_PZOOM_CapZoomReqInputWidth 2560 */
-	{0x0F12, 0x0780},		/*REG_TC_PZOOM_CapZoomReqInputHeight 1920 */
-	{0x0F12, 0x0000},		/*REG_TC_PZOOM_CapZoomReqInputWidthOfs */
-	{0x0F12, 0x0000},		/*REG_TC_PZOOM_CapZoomReqInputHeightOfs */
+	{0x0F12, 0x0A00},	/*REG_TC_PZOOM_CapZoomReqInputWidth 2560 */
+	{0x0F12, 0x0780},	/*REG_TC_PZOOM_CapZoomReqInputHeight 1920 */
+	{0x0F12, 0x0000},	/*REG_TC_PZOOM_CapZoomReqInputWidthOfs */
+	{0x0F12, 0x0000},	/*REG_TC_PZOOM_CapZoomReqInputHeightOfs */
 
 	{0x002A, 0x047C},
-	{0x0F12, 0x0001},		/*REG_TC_THUMB_Thumb_bActive */
-	{0x0F12, 0x0280},		/*REG_TC_THUMB_Thumb_uWidth 640 */
-	{0x0F12, 0x01E0},		/*REG_TC_THUMB_Thumb_uHeight 480 */
+	{0x0F12, 0x0001},	/*REG_TC_THUMB_Thumb_bActive */
+	{0x0F12, 0x0280},	/*REG_TC_THUMB_Thumb_uWidth 640 */
+	{0x0F12, 0x01E0},	/*REG_TC_THUMB_Thumb_uHeight 480 */
 
 	{0x002A, 0x0398},
-	{0x0F12, 0x0A00},		/*REG_0TC_CCFG_usWidth 2560 */
-	{0x0F12, 0x0780},		/*REG_0TC_CCFG_usHeight 1920 */
+	{0x0F12, 0x0A00},	/*REG_0TC_CCFG_usWidth 2560 */
+	{0x0F12, 0x0780},	/*REG_0TC_CCFG_usHeight 1920 */
 
 	{0x002A, 0x024E},
-	{0x0F12, 0x0001},		/*REG_TC_GP_NewConfigSync */
+	{0x0F12, 0x0001},	/*REG_TC_GP_NewConfigSync */
 	{0x002A, 0x0270},
-	{0x0F12, 0x0001},		/*REG_TC_GP_CapConfigChanged */
+	{0x0F12, 0x0001},	/*REG_TC_GP_CapConfigChanged */
 };
 
 //==========================================================
@@ -5655,7 +6273,6 @@ LOCAL SENSOR_REG_T s5k4ec_FAST_AE_Off[] = {
 };
 
 // Settings that should enhance HD-resolution recording (1280x720 and above)
-// TODO: This results to an image that is overexposed, tweak this later
 LOCAL SENSOR_REG_T s5k4ec_enable_camcorder[] =  {
 	{0xFCFC, 0xD000},
 	{0x0028, 0xD000},
@@ -5668,10 +6285,6 @@ LOCAL SENSOR_REG_T s5k4ec_enable_camcorder[] =  {
 
 	{0x0028, 0x7000},
 
-	// AE TARGET
-	{0x002A, 0x1484},
-	{0x0F12, 0x0026},	//003C	 //TVAR_ae_BrAve p //
-
 	// SLOW AE
 	{0x002A, 0x1568},
 	{0x0F12, 0x0030},	// 0010 ae_GainIn_0_			//
@@ -6917,5 +7530,5 @@ LOCAL SENSOR_REG_T s5k4ec_disable_camcorder[] = {
 	{0x0F12, 0x0001},	//	#REG_TC_GP_PrevConfigChanged	//
 	{0x002A, 0x0270},
 	{0x0F12, 0x0001},	//	#REG_TC_GP_CapConfigChanged 	//
-        {0xFFFF, 0xFFFF},
+	{0xFFFF, 0xFFFF},
 };
-- 
2.27.0

