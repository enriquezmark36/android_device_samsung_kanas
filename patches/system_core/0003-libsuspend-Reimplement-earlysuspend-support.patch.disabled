From c633e8cbdc78d803bb3a5677f6c8b58cb9af489f Mon Sep 17 00:00:00 2001
From: Mark Enriquez <enriquezmark36@gmail.com>
Date: Tue, 20 Oct 2020 12:56:30 +0800
Subject: [PATCH] libsuspend: Reimplement earlysuspend support

This is a quick rewrite of the previous earlysuspend libsuspend support
back when the entire libsuspend support is written at C rather than C++.
The rewrite aims to simplify the code and make it properly compile
when passed through a c++ compiler.

One rather quirky behavior here is the callback, where the callback at
the wakeup_count is directly tied to the thread that writes to
the /sys/power/state file. This implementation relies on the
wait_for_fb_* files.

Also, should Google implement the force suspend, it may not be possible
to implement it with earlysuspend since the whole kernel is rigged to
only suspend when wakelock detects that no more wakelocks are active.

If you're a tinkerer or passer by or deparate traveller, consider doing
away with earlysuspend and write a compatibility layer for those
userspace software that still depends on it. Otherwise, I hope this impl.
can help anyone who needs a quick earlysuspend workaround.

P.S. I am not going to use this anyway so it's untested.

Signed-off-by: Mark Enriquez <enriquezmark36@gmail.com>
Change-Id: Icbcc19be8d2ecc095504a402fd0ec8cdd68db1e3
---
 libsuspend/Android.bp                   |   1 +
 libsuspend/autosuspend.c                |   6 +
 libsuspend/autosuspend_earlysuspend.cpp | 155 ++++++++++++++++++++++++
 libsuspend/autosuspend_ops.h            |   1 +
 4 files changed, 163 insertions(+)
 create mode 100644 libsuspend/autosuspend_earlysuspend.cpp

diff --git a/libsuspend/Android.bp b/libsuspend/Android.bp
index b3e36c2bd..2181c3aac 100644
--- a/libsuspend/Android.bp
+++ b/libsuspend/Android.bp
@@ -10,6 +10,7 @@ cc_library {
     srcs: [
         "autosuspend.c",
         "autosuspend_wakeup_count.cpp",
+        "autosuspend_earlysuspend.cpp",
     ],
     export_include_dirs: ["include"],
     local_include_dirs: ["include"],
diff --git a/libsuspend/autosuspend.c b/libsuspend/autosuspend.c
index b87f59cd6..5070d1680 100644
--- a/libsuspend/autosuspend.c
+++ b/libsuspend/autosuspend.c
@@ -32,6 +32,12 @@ static int autosuspend_init(void) {
         return 0;
     }
 
+    autosuspend_ops = autosuspend_earlysuspend_init();
+    if (autosuspend_ops == NULL)
+        ALOGW("failed to initialize earlysuspend");
+    else
+        return 0;
+
     autosuspend_ops = autosuspend_wakeup_count_init();
     if (autosuspend_ops == NULL) {
         ALOGE("failed to initialize autosuspend");
diff --git a/libsuspend/autosuspend_earlysuspend.cpp b/libsuspend/autosuspend_earlysuspend.cpp
new file mode 100644
index 000000000..1a88504c9
--- /dev/null
+++ b/libsuspend/autosuspend_earlysuspend.cpp
@@ -0,0 +1,155 @@
+/*
+ * Copyright (C) 2020 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define LOG_TAG "libsuspend"
+//#define LOG_NDEBUG 0
+
+#include <fcntl.h>
+#include <pthread.h>
+#include <android-base/file.h>
+#include <android-base/logging.h>
+#include <android-base/strings.h>
+
+#include "autosuspend_ops.h"
+
+#define EARLYSUSPEND_SYS_POWER_STATE "/sys/power/state"
+#define EARLYSUSPEND_WAIT_FOR_FB_SLEEP "/sys/power/wait_for_fb_sleep"
+#define EARLYSUSPEND_WAIT_FOR_FB_WAKE "/sys/power/wait_for_fb_wake"
+
+using android::base::WriteStringToFd;
+
+static int state_fd;
+static int wake_fd;
+static int sleep_fd;
+static void (*wakeup_func)(bool success) = NULL;
+static const std::string pwr_state_mem = "mem";
+static const std::string pwr_state_on = "on";
+static pthread_t earlysuspend_thread;
+
+static int blocking_read(int fd) {
+    char just_one_byte;
+    lseek(fd, 0, SEEK_SET);
+    return TEMP_FAILURE_RETRY(read(fd, &just_one_byte, 1));
+}
+
+static void *earlysuspend_thread_func(void __unused *arg)
+{
+    while (1) {
+        LOG(VERBOSE) << "Wait until fb suspends";
+
+        if (blocking_read(sleep_fd) < 0)
+            PLOG(ERROR) << "Failed reading wait_for_fb_sleep";
+
+        LOG(VERBOSE) << "Wait until fb resumes";
+        if (blocking_read(wake_fd) < 0)
+            PLOG(ERROR) << "Failed reading wait_for_fb_wake";
+
+        LOG(VERBOSE) << "Call wakeup callback";
+        if (wakeup_func != NULL)
+            (*wakeup_func)(1);
+    }
+}
+
+static int autosuspend_earlysuspend_enable(void)
+{
+    LOG(VERBOSE) << __func__;
+
+    if (WriteStringToFd(pwr_state_mem, state_fd) == false) {
+        PLOG(ERROR) << "Error writing to " << EARLYSUSPEND_SYS_POWER_STATE;
+        return -1;
+    }
+
+    if ((sleep_fd >= 0) && blocking_read(sleep_fd) < 0)
+        PLOG(WARNING) << "read() failed on wait_for_fb_sleep";
+
+    LOG(VERBOSE) << __func__ << " done";
+    return 0;
+}
+
+static int autosuspend_earlysuspend_disable(void)
+{
+    LOG(VERBOSE) << __func__;
+
+    if (WriteStringToFd(pwr_state_on, state_fd) == false) {
+        PLOG(ERROR) << "Error writing to " << EARLYSUSPEND_SYS_POWER_STATE;
+        return -1;
+    }
+
+    if ((wake_fd >= 0) && blocking_read(wake_fd) < 0)
+        PLOG(WARNING) << "read() failed on wait_for_fb_wake";
+
+    LOG(VERBOSE) << __func__ << " done";
+    return 0;
+}
+
+static void autosuspend_set_wakeup_callback(void (*func)(bool success))
+{
+    if (wakeup_func != NULL)
+        LOG(ERROR) << "Wakeup callback already applied, will not update.";
+    else
+        wakeup_func = func;
+}
+
+static int force_suspend(int timeout_ms)
+{
+    LOG(VERBOSE) << "force_suspend called with timeout: " << timeout_ms;
+
+    autosuspend_earlysuspend_enable();
+    return 1;
+}
+
+static struct autosuspend_ops autosuspend_earlysuspend_ops = {
+    .enable = autosuspend_earlysuspend_enable,
+    .disable = autosuspend_earlysuspend_disable,
+    .force_suspend = force_suspend,
+    .set_wakeup_callback = autosuspend_set_wakeup_callback,
+};
+
+struct autosuspend_ops *autosuspend_earlysuspend_init(void)
+{
+    const char *filename;
+    struct autosuspend_ops *ret = NULL;
+
+    filename = EARLYSUSPEND_SYS_POWER_STATE;
+    state_fd = TEMP_FAILURE_RETRY(open(filename, O_RDWR));
+    if (state_fd < 0)
+        goto acc_err;
+
+    autosuspend_earlysuspend_disable();
+    LOG(INFO) << "Selected early suspend";
+    ret = &autosuspend_earlysuspend_ops;
+
+    filename = EARLYSUSPEND_WAIT_FOR_FB_SLEEP;
+    sleep_fd = TEMP_FAILURE_RETRY(open(filename, O_RDONLY, 0));
+    if (sleep_fd < 0)
+        goto acc_err;
+
+    filename = EARLYSUSPEND_WAIT_FOR_FB_WAKE;
+    wake_fd = TEMP_FAILURE_RETRY(open(filename, O_RDONLY, 0));
+    if (wake_fd < 0) {
+        close(sleep_fd);
+        sleep_fd = -1;
+        goto acc_err;
+    }
+
+    pthread_create(&earlysuspend_thread, NULL, earlysuspend_thread_func, NULL);
+
+    return ret;
+
+acc_err:
+    PLOG(!ret ? ERROR : WARNING) << "Error opening " << filename;
+    return ret;
+}
diff --git a/libsuspend/autosuspend_ops.h b/libsuspend/autosuspend_ops.h
index b0024c8bb..e40f0b3bc 100644
--- a/libsuspend/autosuspend_ops.h
+++ b/libsuspend/autosuspend_ops.h
@@ -26,6 +26,7 @@ struct autosuspend_ops {
 
 __BEGIN_DECLS
 struct autosuspend_ops *autosuspend_wakeup_count_init(void);
+struct autosuspend_ops *autosuspend_earlysuspend_init(void);
 __END_DECLS
 
 #endif
-- 
2.28.0

